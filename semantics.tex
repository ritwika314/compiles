\section{Koord Language and Semantics}
\subsection{Koord model for distributed CPS}

The interaction model of an agent executing a $\lgname$ program is shown in \reffig{arch}. 
\sayan{This has to be rewritten. Too much unstructured text.}

 can be captured by an alternating semantics of discrete and dynamic behavior of the agent. The agents can be viewed as performing \emph{rounds} of execution, where each round consists of a - \emph{A program transition} which is A discrete computational step, and - \emph{An environment transition} which is the dynamic behavior of the agents specified by the controllers. During the program transition in a round, each agent first non-deterministically chooses an \emph{enabled} event, which are all the events whose preconditions evaluate to true. It then executes the statements in the effect of that event. This may involve reading sensor ports, performing computations using local and shared variables, and writing to actuator ports.

The agent then interacts with the physical environments and behaves as dictated by the actuator ports on the controller for $\delta$ amount of time, where $\delta>0$ is a constant \emph{sampling period} parameter. \footnote{\TBD{The sampling parameter can be provided by the user, and each controller that $\lgname$ supports has a default sampling parameter which has been set based on the experiments using the controller. See \refsect{experiments} for more details.}} During this time, the program variables and the actuator port values remain constant, the state of the environment (controller and plant) and the values of the sensor ports change according to the dynamics of the environment.

Compared to $\delta$, the time taken by the agent to execute the computational step is negligible, and in our formalization we treat it as zero logical time. Because each program transition takes zero logical time, we can assume all the agents start and finish executing their program transitions at the same time, and their environment transitions at the same time respectively. Collectively, the (distributed) \emph{system} of all the agents executing this program itself can be captured by an alternating semantics of discrete computational and dynamic behavior.

 In the rest of this section, we present the formal semantics of the $\lgname$ programming language. The complete formalization of the semantics in \K is available from~\cite{} \sayan{webpage/github}. The syntax of the language is presented through examples. 
 
\subsection{Program (cyber) variables and physical variables}


We first discuss the types of variables used by the $\lgname$ programs. Throughout this section we refer to the $\mathit{Task}$ application for discussion.

\paragraph{Program variables}
%$\lgname$ provides several types of access for program variables. 
An agent's $\lgname$ program can access three typed of variables. 
%
-{\em Local program variables\/} record the state of the program. For example, the local variable $p$ of type $\mathit{path}$ (Line~\ref{pathvar}) stores a path for the agent. \\

-{\em Distributed shared variables\/} are used for coordination across agents.  For example, {\bf allwrite} $\mathit{taskList}$ (Line~\ref{awvar}) is a multi-writer list of tasks which can be updated by any participating agent. Shared variables variables can also be single-writer ({\bf allread}). \\ 

-{\em Sensor and actuator variables\/} are used to read from sensor ports and to write to actuator ports. 

Mutual exclusion is always an essential feature when shared variables are involved. $\lgname$ provides a locking mechanism using the keyword $\mathit{atomic}$, which the $\mathit{Assign}$ event uses to update the shared list of tasks $\mathit{taskList}$ safely. $\lgname$ supports two types of shared variables, multiwriter-multireader (\emph{allwrite}), and singlewriter-multireader (\emph{allread}) shared variables, whose functionality is as their names suggest. 
 
\fTBD{Motion related vars}

The agent program specifies the controller which determines the dynamic behavior of each agent and its interaction with the environment. \reffig{arch} shows how  each controller has sensor ports and actuator ports which the agent programs use to interact with the controller and consequently, with the physical environment. The agent program can read from the sensor ports read and write to the actuator ports during the program transition. The sensor ports are updated during the environment transition according to the controller dynamics. 

The $\mathit{Task}$ app  uses a controller called $\mathit{Motion}$ which is expected to drive the robots through a route, as directed by the position value set at its actuator port $\mathit{Motion.route}$. The sensor ports that $\mathit{Motion}$ makes available to the $\mathit{Task}$ program are: - $\mathit{Motion.psn}$: the robot position in a fixed coordinate system (provided by either GPS or an indoor positioning system) - $\mathit{Motion.done}$: A flag indicating whether the $\mathit{Motion}$ controller is active, or finished reaching the previous $\mathit{route}$ target points.The implementation of $\mathit{Motion}$ controller involves, for example, path planners, and platform-specific steering and throttle controllers, and drivers for specific positioning systems. 
 Each agent program also has access to two simulation parameters (a) a unique integer identifier $\myuin$ for itself and (b)  a list $\UINS$ of identifiers of all participating agents. \footnote{This set of participating agents is known and constant.} We now describe the system state, or \emph{configurations} which we use to formalize $\lgname$ semantics. 
 
\subsection{System configurations}

The semantics of a system of agents executing $\lgname$-programs is given in terms of a nondeterministic, timed automaton~\cite{TIOAmon}. The state of the automaton is defined in terms of {\em configurations\/} that include the state of the individual agents, as well as certain global information.

A {\em system configuration\/} with sampling parameter $\delta$ is a tuple 
$\gconfig_\delta = (\lset,{S},\tau,\turn)$, where
\flushleft

 ${L} = \{\lconfig{i}\}_{i\in\UINS}$ is a list of {\em agent configurations\/}--one for each participating agent, where $\UINS$ is the known set of participating agents. $\lconfig{i}$ refers to the configuration of the $i$th element in the list $L$, or the $i$th agent in the system.   \\
 ${S} : Var \mapsto Val$ is the {\em global context\/}, mapping all shared variable names to their values. \\
%Why we need this becomes clear in the next section. 
 $\tau\in \mathbb{R}^{+}$ is the {\em global time\/}.
 $\turn\in\{\mathtt{prog,env}\}$ is a binary \emph{bookkeeping} variable determining whether  program or environment transitions are being processed. 

Bookkeeping variables are invisible in the language syntax, and only used in the semantics. We now define the \emph{agent configurations}, which are used to specify the semantics of each agent. \newline


Given that $\mathbb{P}$ is the set of all the productions in the $\lgname$grammar, $\Var$ is the set of variables, $Val$ be is set of values that an expression in the $\lgname$ can evaluate to, $\Cfield$ is the set of sensor and actuator ports of the controller being used in $P$, the configuration of an agent is a tuple $ l = (P, {M},{w},\cp,\turn)$, where\newline


 $p \in \mathbb{P}$ is the current syntactic production,\newline

 ${M} : \Var \mapsto \Val$ is its {\em local context\/} mapping all variables in $P$ to agent local values.
\newline
 $\mathit{sm} : \mathit{Sens} \mapsto \Val$ is the mapping of sensor variables to values.
\newline
 $\turn \in \{\mathtt{prog,env}\}$ is a bookkeeping variable indicating whether the agent should be executing a program or environment transition. 

The components of an agent configuration in the tuple $l$ are accessed
using the dot (``$.$'') notation, for example, $l.M\equiv
\pi_2(l)$ and $l.w \equiv \pi_3(l)$.
\subsection{Update rules}
We provide the semantics for some of the syntactic productions in $\lgname$, which will help us discuss the semantics of program and environment transitions. The statement semantics are given by update rules of the type
$$\stmtrule\ \subseteq (\pws \times \pwl\times \pwstmt \cup \{\cdot\}) \times \mathscr{P}(\pws\times \pwl \times \pwstmt \cup \{\cdot\}),$$
\fTBD{$\pwstmt$ is very clunky looking, need to change it perhaps?}where $\pwstmt$ refers to the set of all possible statements allowed by language syntax. We introduce the symbol `$\cdot$' to indicate an ``empty" statement, which does not affect the configurations. The update relation takes as input a tuple of (1) an agent configuration, (2) a global context, and (3) a statement, and maps it to a set of such tuples. 

\subsubsection{Program variable/program statement updates}

The following rules display the variable lookup and assignment semantics for $\lgname$. The variable lookup rule \textsc{Var-Lookup-rule} states that every agent has a local copy of every variable in the program, and if an agent is evaluating an expression involving variable $x$, it will replace $x$ with the current value $v$ from the local context $M$. $M[x\mapsto v]$ here refers to the fact that in the map $M$, the key $x$ maps to the value $v$. \textsc{Lvar-assign} describe the semantics of variable assignment. If the right side of the assignment is not a constant, then it is first evaluated, and then substituted.
\begin{mdframed}
\scriptsize
\begin{mathpar}
%
  \hspace{-1in}\inferrule*[Right=\textsc{Var-Lookup}]
    {\agnt.M[x\mapsto v_1]} 
    {\langle{S},\agnt, x \rangle \exprule  \langle{S},\agnt, v \rangle } \label{vl1} \and \qquad\qquad 
  \\

\hspace{-1in} \inferrule*[Right=\sc{lvar-assign}]
    {\begin{array}{l}
    x \notin \mathit{Keys}({S}) \wedge x \in \mathit{Keys}(\agnt .{M}) \cr \wedge {\agnt = (P, {M},\mathit{sm},\mathtt{prog})\ \wedge\ \agnt^\prime = (P,{M}[x\mapsto c],\mathit{sm},  \mathtt{prog})}\end{array} }
    {\langle{S},\agnt, x = c \rangle {\rightarrow_{S}}  \langle{S},\agnt^\prime,\cdot\rangle}\label{va2} \and \qquad\qquad \\
    \end{mathpar}
\end{mdframed}

\noindent

\subsubsection{Shared memory updates}

 The set of all copies of the local copies shared variables can be seen as the \emph{distributed shared memory}. The correctness of a program relies on consistent values of the agents' local values of shared variables. When an agent writes to a variable, it updates its local copy and our implementation of the $\lgname$ framework uses message passing to inform the other agents of the change. 
%
\begin{mdframed}
\scriptsize
\begin{mathpar}
\hspace{-.5in}\inferrule*[Right=\sc{svar-assign}]
    {\begin{array}{l}
    x \in \mathit{Keys}({S}) \wedge x \in \mathit{Keys}(\agnt .{M}) \wedge x \in \agnt.w 
    \wedge\ \agnt = (P, {M},\mathit{sm},\mathtt{prog}) \cr
    \wedge {S}^\prime = {S}[x \mapsto v]
    \wedge\ \agnt^\prime = (P,{M}[x\mapsto v],\mathit{sm}, \mathtt{prog})
    \end{array}
    }
    {\langle{S},\agnt, x = v \rangle {\rightarrow_{S}}  \langle{S}^\prime,\agnt^\prime,\cdot\rangle}\label{va1} \\
    \end{mathpar}
\end{mdframed}
\subsection{Event semantics}

When these event semantics are executed, the $\turn$ of the agent is set to $\mathtt{env}$ indicating that after this execution, an environment transition occurs. The system can display non deterministic behaviors arising from different agents executing their events in different orders. \fTBD{task app will not show non determinism because of atomic, perhaps use braking or lineform here?}
\begin{mdframed}
\scriptsize
\begin{mathpar}
\hspace{-.5in}
\inferrule*[Right=\sc{event}]
    {\begin{array}{l} \mathit{ev} = \s{pre } \mathit{Cond} \s{ eff }\mathit{Ss} \cr \wedge {\agnt= (P,{M},\mathit{sm},\mathtt{prog}) \wedge\ \agnt^\prime =  (P,{M},\mathit{sm},\mathtt{env})\wedge \mathit{eval(\s{pre}, L.M)} }\end{array}} 
    {\langle{S},\agnt, \cdot \rangle {\rightarrow_{S}}  \langle{S},\agnt^\prime, \mathit{Ss} \rangle }\label{e1}\\
        \end{mathpar}
\end{mdframed}

\noindent We now present some rules for control flow in the program. The rules \ref{ss1} ensures that a statement are processed completely before moving on to processing the next statement, and \ref{ss2} ensures that once a statement that has been processed completely, the next statement comes up for processing. 
\begin{mdframed}
	\scriptsize
\begin{mathpar}
\inferrule*[Right=\sc{stmt-seq-1}]
    {\langle{S},\agnt, St_1 \rangle {\rightarrow_{S}}  \langle{S}^\prime,\agnt^\prime, St_1^\prime\rangle}
    {\langle{S},\agnt, St_1\ St_2 \rangle {\rightarrow_{S}}  \langle{S}^\prime,\agnt^\prime, St_1^\prime\ St_2 \rangle}\label{ss1} \and \qquad \\
\inferrule*[Right=\sc{stmt-seq-2}]
   {\;}
    {\langle{S},\agnt, \cdot \ St_2 \rangle {\rightarrow_{S}}  \langle{S},\agnt, St_2 \rangle}\label{ss2}\and \qquad \qquad \qquad \qquad \\
   
\end{mathpar}
\end{mdframed}


\subsection{Alternating synchronous cyber-physical semantics} 


\noindent The advancement of time and environment transitions govern the changes in the system configuration. The rewrite rule is a mapping from an initial system configuration to a set of configurations. It has the type
$$\rightarrow_G\ \subseteq (\mathbb{L}\times \pws \times \mathbb{R}^+\times \mathbb{R}^+\times \{\mathtt{prog,env}\}) \times \mathscr{P}(\mathbb{L}\times\pws \times \mathbb{R}^+\times \mathbb{R}^+ \times \{\mathtt{prog,env}\}) $$

First, we present the semantics of executing the events for each agent. A $\lgname$ program can be seen as sequences of $\stmtrule$ rules, which determine event executions followed by an environment transition. To express this, we define a rule that shows the the changes in the configuration of the overall system due to all the agents executing their program just before an environment transition is applicable.  


\begin{mdframed}
\scriptsize
\begin{mathpar}
\hspace{0.2in}\inferrule*[Right=\sc{SR},Left={$\forall i\in\UINS$}]
{ (S,\lconfig{i},\lconfig{i}.p)\stmtrule(S^\prime,\lconfig{i}^\prime,p^\prime)\stmtrule\ldots\stmtrule (S^{\prime\prime},\lconfig{i}^{\prime\prime},\ \cdot\ )\wedge \lconfig{i}^{\prime\prime}.\turn=\mathtt{env}}
{({L}, S, \tau,  \mathtt{prog})\rightarrow_G ({L^{\prime\prime}}, S^{\prime\prime}, \tau, \mathtt{prog})}\label{runsys}
\end{mathpar}
\end{mdframed}


\fTBD{FIXING Rule REFERENCES}The rule \ref{runsys} expresses that starting from a global configuration $c = ({L}, S, \tau, \mathtt{env})$, each agent $i$ with local configuration $\lconfig{i}$ processes its program $p$ using a sequence of $\stmtrule$ rewrites, until its event is executed, and its $\turn$ set to $\mathtt{env}$ at the end of the event execution. Overall, the system goes from a configuration $c$ to $c^{\prime\prime}= ({L^{\prime\prime}}, S^{\prime\prime}, \tau, \mathtt{env})$, with possibly different agent configurations and global context depending on whether any of the events executed resulted in writes to shared variables.



\fTBD{Agent local states and propagation over messages.}
Suppose the function $f:\mathit{Sens} \times Val \times \mathbb{R} \mapsto \Val$ captures the behavior of the controller, and can be used to update the sensor ports after time $\delta$. The rule \ref{env} shows the semantics of the system configuration after the rule \ref{runsys}.
\begin{mdframed}
    	\scriptsize
    \begin{mathpar}
    \inferrule*[envtrans]{ \forall i \in \UINS,\lconfig{i}^\prime.\mathit{sm} = \agnt.\mathit{f}(\lconfig{i}.\mathit{sm},\delta) \wedge\ \forall x \in \mathit{Keys}({S}),\lconfig{i}'.{M}[x \mapsto S[x]] \wedge \lconfig{i}.\turn = \mathtt{env}}
    { (L, {S}, \tau,\mathtt{prog})\rightarrow_G ({L}^\prime, {S}, \tau + \delta,\mathtt{env}) \label{env}     }
    
 \inferrule*[Right=\sc{agent-env-to-prog}]
     {\begin{array}{l} \forall i \in \UINS , \lconfig{i}.\turn = \mathtt{env} \wedge \lconfig{i}^\prime.\turn = \mathtt{prog} \end{array}}
     {  ({L}, S, \tau, \mathtt{env})\rightarrow_G ({L^\prime}, S, \tau, \mathtt{env}) \label{agntenvturn}     }\\
    
    
    
     \inferrule*[Right=\sc{env-to-prog}]
     { \forall i \in \UINS , \lconfig{i}.\turn = \mathtt{prog} }
     {  ({L}, S,\tau, \mathtt{env})\rightarrow_G ({L}, S, \tau, \mathtt{prog}) \label{envturn}     }
\noindent   
\end{mathpar}
    \end{mdframed}

Rule \ref{agntenvturn} is the semantic rule for setting the $\mathit{turn}$ of each agent back to $\mathtt{prog}$ from $\mathtt{env}$ after the environment transition has been completed. The semantics synchronizes the program transitions of each agent, ensuring that the event executions for each happen every $\delta$ time.
    
    
Rule \ref{env} captures the fact that the global context $S$ is copied into local context of each agent $i \ (\lconfig{i}.M)$, thus ensuring that all agents have consistent shared variable values before the next program transition. After that, rule \ref{envturn} changes the turn of each agent back to program. In an actual execution, the controller  would run the program on hardware, whose sensor ports evolve for $\delta$ time between program transitions.


\fTBD{Relate this to assumptions}


The language syntax is first parsed using a standard indentation parser implemented in python. We implemented $\lgname$ semantics in \K, which a rewriting-based executable framework for defining language semantics. One can view a language semantics naturally as a set of reduction rules over configurations. Components of a configuration are called {\em cells} in \K. To implement the semantics discussed in \refsect{semantics}, the configuration in \K includes several bookkeeping variables as well. 


Semantics in \K is expressed using configurations, which organize the components in elements called {\em cells}. Cells are labelled, have types indicating what kind of elements can be contained in them, and help specify the rewrite rule in context. \K allows underspecification of rewrite rules, meaning, only the rewrite rules affecting part of the configurations need to be specified if the rule doesn't affect the other parts of the rule. Our notion of configurations translate in a straightforward manner to \K configurations. We present a couple of example rewrite rules in \K to demonstrate how the executable semantics is implemented.  


We use a top level {\em system} cell with nested cells corresponding to the elements discussed in \refsect{semantics}, as well as other cells which are used to store information like number of agents in the system, simulation parameters of the program, and other bookkeeping information we used to implement the semantics. There is a special cell called the {\em k} cell, which is used to store the current computation in the program. Each agent has a {\em k} cell to store its computation. Recall that a local variable is updated only in the local memory. The rule for this checks whether the variable is not in the keys of the map {\em sysLoc} from shared variables to their locations. The following rule in \K that corresponds to our \textsc{lvar-assign} rule in the semantics. 
\vspace{2pt}
\begin{mdframed}
\begin{Verbatim}[fontsize=\tiny]
<agent> ... <k> V:Id = I:Val => .  ... </k> 
            <loc> ... V |-> L ... </loc> 
            <locstore> ... L |-> _ => I ... </locstore> 
        ... </agent> 
<sysloc> Rho </sysloc>                    when L notBool inKeys(Rho)        
\end{Verbatim}
\end{mdframed}

We use bookkeeping variables in the \K configuration to ensure that all agents have their turn set to \texttt{env} before the system environment transition.We also  ensure that an agent has updated its sensor ports after the environment transition, to implement the rule \textsc{agent-env-to-prog}. Once all the agents in the system are ready to perform the next program transition, the rule \textsc{env-to-prog} is implemented as follows. If the number of agents which have set their $\mathit{turn}$ to $\mathit{env}$ (indicated by the cell {\em envToProg}) is the same as the number of all agents in the system, then the system sets its turn from $\mathit{Env}$ to $\mathit{Prog}$. 
\vspace{2pt}
\begin{mdframed}
\begin{Verbatim}[fontsize=\tiny]
<system>...
 <envToProg> N </envToProg>
 <numAgents> N </numAgents>  
 <turn> Env => Prog </turn> ... 
</system>                      
\end{Verbatim}
\end{mdframed}