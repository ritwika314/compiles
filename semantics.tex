\section{Koord Language and Semantics}
\subsection{Koord model for distributed CPS}

The interaction model of an agent executing a $\lgname$ program is shown in \reffig{arch}. 
\sayan{This has to be rewritten. Too much unstructured text.}

\sayan{The notion of turn has to be introduced.}
$\lgname$ design comprises of a \emph{turn}-based alternating semantics of discrete and dynamic behavior of each agent in the distributed system. The agents can be viewed as performing \emph{rounds} of execution, where each round consists of a \begin{inparaenum} \item \emph{A program transition} which is a discrete computational step, and \item \emph{An environment transition} which is the dynamic behavior of the agents specified by the controllers \end{inparaenum}. In our semantics, we represent whether it is the turn of a program transition or an environment transition to be executed on each agent by a $\mathit{turn}$ variable.  

In a program transition in a round, each agent first nondeterministically chooses an \emph{enabled} event, or an event whose precondition evaluates to \verb|True|. It then executes the statements in the effect of that event. %This may involve reading sensor ports, performing computations using local and shared variables, and writing to actuator ports. 
Then, the agent performs the environment transition in the round, during which it interacts with the physical environment and behaves as dictated by the actuator ports on the controller for $\delta$ amount of time.  \footnote{ $\delta>0$ is a constant \emph{sampling period} parameter. The sampling parameter can be provided by the user, and each controller that $\lgname$ supports has a default sampling parameter which has been set based on the experiments using the controller. See \refsect{experiments} for more details.} %During this time, the program variables and the actuator port values remain constant, the state of the environment (controller and plant) and the values of the sensor ports change according to the dynamics of the environment.

\sayan{Moved from later.
The agent program specifies the controller which determines the dynamic behavior of each agent and its interaction with the environment. \reffig{arch} shows how  each controller has sensor ports and actuator ports which the agent programs use to interact with the controller and consequently, with the physical environment. The agent program can read from the sensor ports read and write to the actuator ports during the program transition. The sensor ports are updated during the environment transition according to the controller dynamics. 
}

Compared to $\delta$, the time taken by the agent to execute the computational step is negligible, and in our formalization we treat it as zero logical time. Because each program transition takes zero logical time, we can assume all the agents start and finish executing their program transitions at the same time, and their environment transitions at the same time respectively. As our design choices impose this synchronicity on all agent executions, the system can also be seen to be executing program and environment transition by \emph{turns}, where all the agents execute the environment transitions in a round only after all of them have finished executing the program transitions in that round.  

%Collectively, the (distributed) \emph{system} of all the agents executing this program itself can be captured by an alternating semantics of discrete computational and dynamic behavior.

 In the rest of this section, we present the formal semantics of the $\lgname$ programming language. The complete formalization of the semantics in \K is available from~\cite{} \sayan{webpage/github}. The syntax of the language is defined using a BNF grammar, provided in full for the interested reader in \rg{the appendix}.
 
\subsection{Program (cyber) variables and physical variables}
\label{sec:variables}
We first introduce the types of variables used by the $\lgname$ programs. Throughout, we refer to the $\mathit{Task}$ application as an exmaple.

\paragraph{Program variables}
%$\lgname$ provides several types of access for program variables. 
An agent's $\lgname$ program can access three types of variables. 
%
\begin{itemize}
	\item {\em Local program variables\/} record the state of the program. For example, the variable $p$ of type $\mathit{path}$ (Line~\ref{pathvar}) stores a path for the agent. 
\item {\em Distributed shared variables\/} are used for communication across agents.  For example, {\bf allwrite} $\mathit{taskList}$ (Line~\ref{awvar}) is a multi-writer list of tasks which can be written-to and read-from by all participating agents. Shared variables can also be single-writer multi-reader ({\bf allread}). 
\item {\em Port variables\/} are used to read from and write to sensor and actuator ports of the agent. For example, the $\mathit{Motion}$ controller for the $\mathit{Task}$ app  drives the agent  through a route, as directed by value set at the actuator port $\mathit{Motion.route}$. The sensor port $\mathit{Motion.psn}$ gives the position of the agent (in a fixed coordinate system) and $\mathit{Motion.done}$ indicates  whether the $\mathit{Motion}$ controller is active or inactive.
\end{itemize}
The valuation of these variables define the configuration for an agent. 
%Also, should 
The agent program also has access to two system-level constant parameters (a) a unique integer identifier $\myuin$ for itself and (b) a list $\UINS$ of identifiers of all participating agents\footnote{Our current system implementation assumes that the set of possible participating agents is known. This assumption will be relaxed in the future.}. 

\paragraph{Agent configurations}
The  syntax and grammar for $\lgname$ is given in the Appendix. 
Let us fix $P$ to be a syntactically correct agent program. Let $\Var$ be the set of program and shared variables in $P$. Let $\mathit{Sens}$ be the set of sensor ports of the controller used in $P$. Let $\mathit{Val}$ be the set possible valuations that these variables can take. 
%Given that $\mathbb{P}$ is the set of all the productions in the $\lgname$ grammar,  being used in $P$, 
A {\em configuration\/} of agent $\mathit{i}$, $i \in \UINS$, running $\lgname$ program $P$ is a tuple $ L_i = (\mathit{pc}, {M},\mathit{sm},\turn)$, where
\begin{itemize}
 \item $\mathit{pc}$ is a syntactic production that generates $P$. 
\item ${M} : \Var \mapsto \Val$ is a {\em local context\/} mapping each variable to a corresponding valuation.
 \item $\mathit{sm} : \mathit{Sens} \mapsto \Val$ is a mapping of each sensor port to a valuation.
 \item $\turn:\{\mathtt{prog,env}\}$ is a bookkeeping variable; $\turn = \mathtt{env}$ indicates that agent $i$ has finished executing its program for the current round.  
\end{itemize}
The components of an agent configuration in the tuple $L_i$ are accessed using the usual dot ($\cdot$) notation. That is, $L_i.M$ refers to the local context $M$ in agent configuration $L_i$, for the agent with pid $i$ in the system.

\subsection{System configurations}

We define the semantics of the overall system in terms of a nondeterministic, hybrid automaton~\cite{TIOAmon}. The state of the automaton is defined in terms of {\em configurations\/} consisting of the state components of the individual agents and the physical environment. 

A {\em system configuration\/} with sampling parameter $\delta>0$ is a tuple 
$\gconfig_\delta = (\lset,{S},\tau,\turn)$, where
\begin{itemize}
	\item ${L} = \{\lconfig{i}\}_{i\in\UINS}$ is a list of {\em agent configurations\/}; $\lconfig{i}$ is the  configuration of the $i^{\mathit{th}}$ agent.
	\item ${S} : \mathit{Var} \mapsto \mathit{Val}$ is the {\em global context\/}, which is a mapping of all shared variable names to their values, 
	\item  $\tau:\mathbb{R}^{\geq 0}$ is the {\em global time\/}.
	\item $\turn\in\{\mathtt{prog,env}\}$ is a binary bookkeeping variable which represents whether the system is performing a program or environment transition. 
\end{itemize}

%Bookkeeping variables are invisible in the language syntax, and only used in the semantics. We now define the \emph{agent configurations}, which are used to specify the semantics of each agent. \newline

\sayan{Stopping here. Several things undefined at this point. Koord grammar. Why is agent configuration $l$ and not $L_i$ as defined above?}

\subsection{Update rules}
We provide the semantics for some of the syntactic productions in $\lgname$, which will help us discuss the overall semantics of program and environment transitions. Program transitions are mainly comprised of execution of statements. The statement semantics are given by update rules of the type
$$\stmtrule\ \subseteq (\pws \times \pwl\times \mathit{Stmts} \cup \{\cdot\}) \times \mathscr{P}(\pws\times \pwl \times \mathit{Stmts} \cup \{\cdot\}),$$
%\fTBD{$\pwstmt$ is very clunky looking, need to change it perhaps?}
where $\mathit{Stmts}$ refers to the set of all possible statements allowed by language syntax. We introduce the symbol `$\cdot$' to indicate an ``empty" statement, which does not affect the configurations. The update relation takes as input a tuple of (1) an agent configuration, (2) a global context, and (3) a statement, and maps it to a set of such tuples. 
\subsubsection{Program variable/program statement updates}

The following rules display the variable lookup and assignment semantics for $\lgname$. The variable lookup rule \textsc{Var-Lookup} states that every agent has a local copy of every variable in the program, and if an agent is evaluating an expression involving variable $x$, it will replace $x$ with the current value $v$ from the local context $M$. $M[x\mapsto v]$ here refers to the fact that in the map $M$, the key $x$ maps to the value $v$. \textsc{Lvar-assign} describes the semantics of a local variable assignment. $x\notin \mathit{Keys}(S) \wedge x \in \mathit{Keys(L.M)}$ represents the fact that there is no mapping from $x$ in the global context $S$, but there is one in the local context $L.M$. 

\begin{mdframed}
\scriptsize
\begin{mathpar}
%
  \hspace{-1in}\inferrule*[Right=\textsc{Var-Lookup}]
    {\agnt.M[x\mapsto v_1]} 
    {\langle{S},\agnt, x \rangle \exprule  \langle{S},\agnt, v_1 \rangle } \label{vl1} \and \qquad\qquad 
  \\

\hspace{-1in} \inferrule*[Right=\sc{lvar-assign}]
    {\begin{array}{l}
    x \notin \mathit{Keys}({S}) \wedge x \in \mathit{Keys}(\agnt .{M}) \cr \wedge {\agnt = (P, {M},\mathit{sm},\mathtt{prog})\ \wedge\ \agnt^\prime = (P,{M}[x\mapsto c],\mathit{sm},  \mathtt{prog})}\end{array} }
    {\langle{S},\agnt, x = c \rangle {\rightarrow_{S}}  \langle{S},\agnt^\prime,\cdot\rangle}\label{va2} \and \qquad\qquad \\
    \end{mathpar}
\end{mdframed}

\noindent

\subsubsection{Shared memory updates}

 The set of all copies of the local copies shared variables can be seen as the \emph{distributed shared memory}. The correctness of a program relies on consistent values of the agents' local values of shared variables. When an agent writes to a variable, it updates its local copy and our implementation of the $\lgname$ framework uses message passing to inform the other agents of the change. 
%
\begin{mdframed}
\scriptsize
\begin{mathpar}
\hspace{-.5in}\inferrule*[Right=\sc{svar-assign}]
    {\begin{array}{l}
    x \in \mathit{Keys}({S}) \wedge x \in \mathit{Keys}(\agnt .{M}) 
    \wedge\ \agnt = (P, {M},\mathit{sm},\mathtt{prog}) \cr
    \wedge {S}^\prime = {S}[x \mapsto v]
    \wedge\ \agnt^\prime = (P,{M}[x\mapsto v],\mathit{sm}, \mathtt{prog})
    \end{array}
    }
    {\langle{S},\agnt, x = v \rangle {\rightarrow_{S}}  \langle{S}^\prime,\agnt^\prime,\cdot\rangle}\label{va1} \\
    \end{mathpar}
\end{mdframed}
\subsection{Event semantics}

The statement semantics are only defined when the turn of the agent was set to \texttt{prog}. We first present some rules for control flow in the program. The rules \textsc{stmt-seq-1} ensures that a statement are processed completely before moving on to processing the next statement, and \textsc{stmt-seq-2} ensures that once a statement that has been processed completely, the next statement comes up for processing. 
\begin{mdframed}
	\scriptsize
\begin{mathpar}
\inferrule*[Right=\sc{stmt-seq-1}]
    {\langle{S},\agnt, St_1 \rangle {\rightarrow_{S}}  \langle{S}^\prime,\agnt^\prime, St_1^\prime\rangle}
    {\langle{S},\agnt, St_1\ St_2 \rangle {\rightarrow_{S}}  \langle{S}^\prime,\agnt^\prime, St_1^\prime\ St_2 \rangle}\label{ss1} \and \qquad \\
\inferrule*[Right=\sc{stmt-seq-2}]
   {\;}
    {\langle{S},\agnt, \cdot \ St_2 \rangle {\rightarrow_{S}}  \langle{S},\agnt, St_2 \rangle}\label{ss2}\and \qquad \qquad \qquad \qquad \\
   
\end{mathpar}
\end{mdframed}


Given the control flow statements, the following rules capture two facts. Rule \textsc{event} states that only the effect of an an enabled event may be executed, and a marker \emph{endEvent} is added after the effect of that event to indicate that the event has executed. Rule \textsc{prog-to-env} states that
after the event is executed, the $\turn$ of the agent is set to $\mathtt{env}$ indicating that after this execution, an environment transition occurs. We will demonstrate in \refsect{experiments} that the system can display non deterministic behaviors arising from different agents executing their events in different orders.
\begin{mdframed}
\scriptsize
\begin{mathpar}
\hspace{-.5in}
\inferrule*[Right=\sc{event}]
    {\begin{array}{l} \mathit{ev} = \s{pre } \mathit{Cond} \s{ eff }\mathit{Ss} \cr \wedge {\agnt= (P,{M},\mathit{sm},\mathtt{prog}) \wedge\ \agnt^\prime =  (P,{M},\mathit{sm},\mathtt{prog})\wedge \mathit{eval(\s{pre}, L.M)} }\end{array}} 
    {\langle{S},\agnt, \cdot \rangle {\rightarrow_{S}}  \langle{S},\agnt^\prime, \mathit{Ss;endEvent} \rangle }\label{e1}\\
\hspace{-.5in}
    \inferrule*[Right=\sc{prog-to-env}]
    {\begin{array}{l} {\agnt= (P,{M},\mathit{sm},\mathtt{prog}) \wedge\ \agnt^\prime =  (P,{M},\mathit{sm},\mathtt{env}) }\end{array}} 
    {\langle{S},\agnt, \mathit{endEvent} \rangle {\rightarrow_{S}}  \langle{S},\agnt^\prime, \cdot \rangle }\label{e1}
        \end{mathpar}
\end{mdframed}




\subsection{Alternating synchronous cyber-physical semantics} 


\noindent The advancement of time and environment transitions govern the changes in the system configuration. The rewrite rule is a mapping from an initial system configuration to a set of configurations. It has the type
$$\rightarrow_G\ \subseteq (\mathbb{L}\times \pws \times \mathbb{R}^+\times \{\mathtt{prog,env}\}) \times \mathscr{P}(\mathbb{L}\times\pws \times \mathbb{R}^+ \times \{\mathtt{prog,env}\}) $$

First, we present the semantics of executing the events for all agents. A $\lgname$ program can be seen as sequences of $\stmtrule$ rules, which determine event executions followed by an environment transition. To express this, we define a rule that shows the the changes in the configuration of the overall system due to all the agents executing their program just before an environment transition is applicable.  


\begin{mdframed}
\scriptsize
\begin{mathpar}
\hspace{0.2in}\inferrule*[Right=\sc{run},Left={$\forall i\in\UINS$}]
{ (S,\lconfig{i},\lconfig{i}.p)\stmtrule(S^\prime,\lconfig{i}^\prime,p^\prime)\stmtrule\ldots\stmtrule (S^{\prime\prime},\lconfig{i}^{\prime\prime},\ \cdot\ )\wedge \lconfig{i}^{\prime\prime}.\turn=\mathtt{env}}
{({L}, S, \tau,  \mathtt{prog})\rightarrow_G ({L^{\prime\prime}}, S^{\prime\prime}, \tau, \mathtt{env})}\label{runsys}
\end{mathpar}
\end{mdframed}


\fTBD{FIXING Rule REFERENCES}The rule \textsc{run}  expresses that starting from a global configuration $c = ({L}, S, \tau, \mathtt{env})$, each agent $i$ with local configuration $\lconfig{i}$ processes its program $p$ using a sequence of $\stmtrule$ rewrites, until its event is executed, and its $\turn$ set to $\mathtt{env}$ at the end of the event execution. Overall, the system goes from a configuration $c$ to $c^{\prime\prime}= ({L^{\prime\prime}}, S^{\prime\prime}, \tau, \mathtt{env})$, with possibly different agent configurations and global context depending on whether any of the events executed resulted in writes to shared variables.



%\fTBD{Agent local states and propagation over messages.}
Now that we have the semantics for system to finish the program transition, we present the semantics for environment transitions, and how the \emph{turn} resets to \verb|prog|. Suppose the function $f:\mathit{Sens} \times Val \times \mathbb{R} \mapsto \Val$ captures the behavior of the controller, and can be used to update the sensor ports after time $\delta$. The rule \textsc{envtrans} shows the semantics of the system configuration after the rule \ref{runsys}.
\begin{mdframed}
    	\scriptsize
    \begin{mathpar}
    \inferrule*[Right =\sc{envtrans}]{ \begin{array} \forall i \in \UINS,\lconfig{i}^\prime.\mathit{sm} = \agnt.\mathit{f}(\lconfig{i}.\mathit{sm},\delta) \wedge\cr \forall x \in \mathit{Keys}({S}),\lconfig{i}'.{M}[x \mapsto S[x]] \wedge \lconfig{i}.\turn = \mathtt{env} \end{array}}
    { (L, {S}, \tau,\mathtt{prog})\rightarrow_G ({L}^\prime, {S}, \tau + \delta,\mathtt{env}) \label{env}     }
    \\
  \hspace{-1in}  
 \inferrule*[Right=\sc{agent-env-to-prog}]
     {\begin{array}{l} \forall i \in \UINS , \lconfig{i}.\turn = \mathtt{env} \wedge \lconfig{i}^\prime.\turn = \mathtt{prog} \end{array}}
     {  ({L}, S, \tau, \mathtt{env})\rightarrow_G ({L^\prime}, S, \tau, \mathtt{env}) \label{agntenvturn}   \and \qquad \qquad }\\
    
    
    
     \inferrule*[Right=\sc{env-to-prog}]
     { \forall i \in \UINS , \lconfig{i}.\turn = \mathtt{prog} }
     {  ({L}, S,\tau, \mathtt{env})\rightarrow_G ({L}, S, \tau, \mathtt{prog}) \label{envturn}     }
\noindent   
\end{mathpar}
    \end{mdframed}

Rule \textsc{agnt-env-to-prog} is the semantic rule for setting the $\mathit{turn}$ of each agent back to $\mathtt{prog}$ from $\mathtt{env}$ after the environment transition has been completed. The semantics synchronizes the program transitions of each agent, ensuring that the event executions for each happen every $\delta$ time.
    
    
Rule \textsc{envtrans} captures the fact that the global context $S$ is copied into local context of each agent $i \ (\lconfig{i}.M)$, thus ensuring that all agents have consistent shared variable values before the next program transition. After that, rule \textsc{env-to-prog} changes the turn of each agent back to program. In an actual execution, the controller  would run the program on hardware, whose sensor ports evolve for $\delta$ time between program transitions. 

\fTBD{Relate this to assumptions}
\subsection{Implementation in K}

The language syntax is first parsed using a standard indentation parser implemented in python. We implemented $\lgname$ semantics in \K, which a rewriting-based executable framework for defining language semantics. One can view a language semantics naturally as a set of reduction rules over configurations. Components of a configuration are called {\em cells} in \K. To implement the semantics discussed in \refsect{semantics}, the configuration in \K includes several bookkeeping variables as well. 


Semantics in \K is expressed using configurations, which organize the components in elements called {\em cells}. Cells are labelled, have types indicating what kind of elements can be contained in them, and help specify the rewrite rule in context. \K allows underspecification of rewrite rules, meaning, only the rewrite rules affecting part of the configurations need to be specified if the rule doesn't affect the other parts of the rule. Our notion of configurations translate in a straightforward manner to \K configurations. We present a couple of example rewrite rules in \K to demonstrate how the executable semantics is implemented.  


We use a top level {\em system} cell with nested cells corresponding to the elements discussed in \refsect{semantics}, as well as other cells which are used to store information like number of agents in the system, simulation parameters of the program, and other bookkeeping information we used to implement the semantics. There is a special cell called the {\em k} cell, which is used to store the current computation in the program. Each agent has a {\em k} cell to store its computation. Recall that a local variable is updated only in the local memory. The rule for this checks whether the variable is not in the keys of the map {\em sysLoc} from shared variables to their locations. The following rule in \K that corresponds to our \textsc{lvar-assign} rule in the semantics. 
\vspace{2pt}
\begin{mdframed}
\begin{Verbatim}[fontsize=\tiny]
<agent> ... <k> V:Id = I:Val => .  ... </k> 
            <loc> ... V |-> L ... </loc> 
            <locstore> ... L |-> _ => I ... </locstore> 
        ... </agent> 
<sysloc> Rho </sysloc>                    when L notBool inKeys(Rho)        
\end{Verbatim}
\end{mdframed}

We use bookkeeping variables in the \K configuration to ensure that all agents have their turn set to \texttt{env} before the system environment transition.We also  ensure that an agent has updated its sensor ports after the environment transition, to implement the rule \textsc{agent-env-to-prog}. Once all the agents in the system are ready to perform the next program transition, the rule \textsc{env-to-prog} is implemented as follows. If the number of agents which have set their $\mathit{turn}$ to $\mathit{env}$ (indicated by the cell {\em envToProg}) is the same as the number of all agents in the system, then the system sets its turn from $\mathit{Env}$ to $\mathit{Prog}$. 
\vspace{2pt}
\begin{mdframed}
\begin{Verbatim}[fontsize=\tiny]
<system>...
 <envToProg> N </envToProg>
 <numAgents> N </numAgents>  
 <turn> Env => Prog </turn> ... 
</system>                      
\end{Verbatim}
\end{mdframed}
