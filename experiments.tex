\section{Case studies showcasing features of $\lgname$ language and simulator}
\label{sec:experims}
The $\lgname$ simulator provides the user a way to test, debug and demonstrate the application program. The simulator enables one to write physics models for different types of robots and simulate the same application code executing on a heterogeneous collection, without incurring the cost of hardware deployment. In this section, we present three case studies to demonstrate some of the important features of the $\lgname$ language and its  simulator.

\subsection{Platooning}
%end to end
\label{sec:platooning}
Figure~\ref{fig:platooningapp} shows the $\lgname$ program for a simplified platooning protocol for vehicles on a single lane. The position of successive vehicles is communicated through  {\bf allread} shared variable $\mathit{x}$. The goal is to maintain a minimal  \emph{safe} separation  between any two consecutive cars. For the sake of simplicity, here the leading car  has a preprogrammed behavior (it sets its acceleration to $2$ or $-2$ every $10$ rounds); in a more realistic deployment this behavior could be based on speed limits or other traffic. 
%The motion controller for the car has bounds on highest and lowest velocities allowed. 
Every other car in the platoon with pid $i$ sets the actuator, namely, its acceleration based on its distance from the car with pid $i+1$; slowing down when the separation is less than the safe distance, accelerating otherwise. 
%The cars communicate through the \emph{allread} variable $\mathit{pos}$, which they update every time they execute the event \emph{SetAcc}, or, as the semantics dictates, every $\delta$ time units.

\begin{figure}[ht!]
    \noindent
    \begin{mdframed}
    \begin{center}
        \scriptsize
        \two{0.4}{0.6}
        {\lstinputlisting[language=xyzNums,firstline=1,lastline=21,frame=none]{code/platooning2.tex}}
        {\lstinputlisting[language=xyzNums,firstline=22,frame=none,firstnumber=22]{code/platooning2.tex}}
    \end{center}
    \end{mdframed}
    \caption{$\lgname$ program for robot $i$ in a Platoon to adjust its $x$ acceleration accordingly .}
    \label{fig:platooningapp}
\end{figure}

%\sayan{Why some ifs have ( ) others do not? Let us use x as position like in lineform.}

\reffig{platoon} shows the resulting $x$ vs $\mathit{time}$ plots for different values of $\delta$, or the duration of the environment transition in \reffig{platoon}. These plots were saved directly from the simulator, and the blue progress bar on the top of the plot shows how far in the current simulation this plot is generated.

\begin{figure}[ht!]
\begin{minipage}{0.5\textwidth}
\includegraphics[width=.5\textwidth]{figs/braking_acc.png}\hfill
%\includegraphics[width=.3\textwidth]{figs/Platooning_2.png}}\hfill%
\includegraphics[width=.5\textwidth]{figs/braking_bad.png}
\end{minipage}%
	\caption{\small {Platoon of four cars. \emph{Left} for $\delta = 0.01$, the cars eventually get to safe separations, while reacting to the first car changing its acceleration periodically} and \emph{Right} for $\delta = 0.1$, this shows an unsafe execution where the simulation stops upon a collision.}
\label{fig:platoon}
\end{figure}

%FIGURE OUT THE VERIFICATION. 
% While the simulator enables quick cycles of development and testing, the verification component, as stated earlier, allows the user to tune the conditions under which the program exhibits desired behavior. 
 A \emph{correct} program should ensure that at no point, the separation along the $x$-axis between two of agents is less than the required safe distance.  Note, that the variable $\emph{safedist}$ needs to be set to higher than the actual required separation to account for reacting to the previous vehicle updating its $\mathit{x}$ value, depending on how long the sampling parameter $\delta$ is. Every car updates its $x$ value every $\delta$ time units. If $\delta$ is too long, then the cars will not slow down even when the separation between then might have become less than the safe distance. We verified using our bounded model checker, that \emph{Platoon} (\reffig{platooningapp}) was indeed safe (for four cars) when $\delta$ is small enough and has potential unsafe behaviors otherwise.\reffig{platoon}(Right) shows the $x$ vs $\mathit{time}$ when the $\delta$ is too long.
%\sayan{Last 2 sentences are not clear. What changed between the safe and the unsafe scenarios? Explain clearly. Put a box around the code.}

\subsection{Formation}
%portability
\label{sec:formation}
We used $\lgname$ to implement some standard robotics \emph{formation} programs, with self-stabilizing behavior. The \emph{Lineform} app (\reffig{lineform}) uniformly lines up the positions of  agents between the robots with the minimum and maximum $pid$. For the non-extremal agents, it sets the target way-point as the mid-point of the position of its neighbors. This type of linear update rule of is an example of hundreds of textbook algorithms for distributed consensus, rendezvous, optimization, swarm flocking, pattern formation~\cite{Tsitsiklis:1986,Blondel,Magnusbook2010} that are directly translated to working implementations using $\lgname$. The mathematical description of the algorithm found in control theory textbooks is shown in the \reffig{lineform} (\emph{Right}). 

%\begin{figure}[ht!]
%	\label{fig:lineform}
%	\noindent
%	\begin{center}
%		\scriptsize
%		\two{0.4}{0.6}
%		{\lstinputlisting[language=xyzNums,frame=none]{code/lineform.tex}}
%		{ \vspace{0.1in}
%                        $x_{t+1} = Ax_{t}$, where \\
%			$x_0$: vector of initial position of agents, \\
%			$x_{t}$: position vector at time $t$, and \\
%		        $A$: is the \emph{transition matrix}, for lineform  \\
%                  
%			$A  = \left[ \begin{array}{ccccc}
%			0 & 0 & 0 & 0 & 0\\
%			\frac{1}{2} & 0 & \frac{1}{2} & 0 & 0\\
%			0 & \frac{1}{2} & 0 & \frac{1}{2} & 0  \\
%			0 & 0 & \frac{1}{2} & 0 & \frac{1}{2} \\
%			0 & 0 & 0 & 0 & 0\\			
%			\end{array}\right]$
%			}
%	\par
%        
%	\end{center}
%	\caption{\small $\lgname$ program for line formation ({\em Left}) and its mathematical counterpart in robotics and control textbooks ({\em Right}).}
%\end{figure}

The shared \emph{allread} variable $p$ (Line\ref{lineformp}) is used by the agents to communicate their position to the other robots. The function \emph{midpoint} is a part of the library functions provided for the data type \emph{pos}; where $$\mathit{midpoint}(p_1,p_2,\ldots,p_n) = pos(\frac{\Sigma_n p_i.x}{n},\frac{\Sigma_n p_i.y}{n},\frac{\Sigma_n p_i.z}{n}) $$.


With the addition of an explicit neighbor relation, the \emph{Squareform} app as shown in \reffig{squareform} can be used to generate a rhombus shape in the plane formed by four extremal points. The code defines a local variables $nbrs$ which is a static list of list of integers, where the $i$th element is a list of the $\mathit{pid}$s of the neighbors of the agent with $\mathit{pid}$ $i$. The list of $\mathit{pid}$s of the extremal points is stored in a list of integers called $\mathit{corners}$. If the agent $\mathit{pid}$ is not in $\mathit{corners}$ , then it moves to the mid point of all its neighbors. \footnote{We omit the actual initialization of the variables $\mathit{nbrs}$ and $\mathit{corner}$, as it depends on the simulation parameters.}

\begin{figure}[ht!]
    \noindent
    \begin{mdframed}
    \begin{center}
        \scriptsize
        \two{0.4}{0.6}
        {\lstinputlisting[language=koordNums,firstline=1,lastline=10,frame=none]{code/shapeform.tex}}
        {\lstinputlisting[language=koordNums,firstline=11,frame=none,firstnumber=11]{code/shapeform.tex}}
    \end{center}
    \end{mdframed}
    \caption{$\lgname$ program for robot $i$ to move to move to the mid point of all its neighbors, with all agents in the system eventually forming a rhombus.}
    \label{fig:squareform}
\end{figure}

\reffig{shapeplots} shows two screenshots of the 3d-simulation for the \emph{Shapeform} app with 25 agents. 


\begin{figure}[h!]
\begin{minipage}{0.5\textwidth}
\includegraphics[width=.5\textwidth]{figs/formation1.png}\hfill
\includegraphics[width=.5\textwidth]{figs/formation4.png}\hfill%
%\includegraphics[width=.3\textwidth]{figs/Platooning_2.png}}\hfill%
\end{minipage}%
\caption{$x$ vs $y$ vs $z$ plots for shapeform. The grey trails represent the positions of the agents in the last 150 time steps.}
\label{fig:shapeplots}

\end{figure}

\subsection{Task}

 \reffig{taskapp} shows the distributed task allocation application written in $\lgname$. Distributed task allocation is challenging as it involves mutual exclusion as well as construction of de-conflicted paths to task locations. Tasks can be abstractions for real location-based objectives like package delivery, surveillance, or fire-fighting. 

We implement a simple task allocation strategy using shared variables for coordination. Mutual exclusion is always an essential feature when shared variables are involved. $\lgname$ provides a locking mechanism using the keyword $\mathit{atomic}$, which the $\mathit{Assign}$ event uses to update the shared list of tasks $\mathit{taskList}$ safely. 

We used a Dubin's vehicle model for our agents, and RRT-based path planning in this application, to avoid static obstacles specified in the initial configuration file. 

\begin{figure}[h!]
\begin{minipage}{0.5\textwidth}
%\includegraphics[width=.5\textwidth]{figs/task1.png}\hfill
%\includegraphics[width=.5\textwidth]{figs/task2.png}}\hfill%
%\includegraphics[width=.3\textwidth]{figs/Platooning_2.png}}\hfill%
\end{minipage}%
\caption{$x$ vs $y$ plots for Task App. The grey trails represent the positions of the agents in the last 150 time units, the blue dots represent the task locations of the incomplete tasks, and the green dots represent the task locations of the completed tasks. The black squares represent static obstacles. }
\label{fig:taskplots}
\end{figure}
We can also easily replace the Motion automaton (consequently, the dynamical model) of any of the agents in the program, and run the same code on them for coordinating the tasks. Using different control parameters, and path planning parameters for the same motion automaton we obtain different statistics for task completion and distance traversal as depicted in in \reffig{tasksstats}. This heterogeneity and portability can be useful for coordinating the same application between different hardware platforms.   
\begin{figure}[h!]
\begin{minipage}{0.5\textwidth}
%\includegraphics[width=.5\textwidth]{figs/taskplot1.png}\hfill
%\includegraphics[width=.5\textwidth]{figs/taskplot2.png}}\hfill%
%\includegraphics[width=.3\textwidth]{figs/Platooning_2.png}}\hfill%
\end{minipage}%
\caption{\small \emph{Left:} Task completion times with different configurations of agents. \emph{Right:}Min, Max and average distances travelled by each agent in different configurations.}. 
\label{fig:taskstats}
\end{figure}

 For all agents operating with the same motion automaton and dynamics model, We observed that conflict resolution took more time with more agents, as expected (\reffig{completionstats}). The completion time remained relatively stable. The maximum and minimum distances travelled were relatively closer with more robots. However, all these results were affected by the non-determinism in choice of paths and tasks by the agents, and their previous relative positions at the moment of choosing the next task as well. These results demonstrate a capability of covering various scenarios in simulation without having to incur the cost of hardware deployment.  
 
\fTBD{placeholder plot}\begin{figure}[h!]
\includegraphics[width=.5\textwidth]{figs/completion.png}\hfill
\caption{\small  Blue-  total completion time and orange- time taken for conflict resolution in seconds}. 
\label{fig:completionstats}
\end{figure}