\section{Koord Software Stack}
\label{sec:software}

\subsection{Runtime system}



To run a $\lgname$ program (hardware or simulation), the user has to provide a configuration file, with 
\begin{inparaenum}
\item the number of agents, 
\item in case of simulation, the initial positions of the agents and the length of the simulation and 
\item in case of hardware deployment their IP addresses, 
and the localization system.
\end{inparaenum} 

\subsection{Key environment assumptions} 


\subsubsection{Periodic event execution semantics}


\subsubsection{Shared variable implementation over message passing}


\subsubsection{Known set of participants}
\subsubsection{Portability and heterogeneity}


\subsection{Simulator}
\subsubsection{gazebo environment}
\subsubsection{car model}
\subsubsection{lidar}
\subsubsection{positioning}
\subsubsection{sampled sensing}
\subsubsection{synchronization issues}
 
\subsection{The Distributed Mapping Problem}
In this section, we introduce the distributed mapping problem that the $\lgname$ program shown in \reffig{mapapp} aims to solve. The key difference between distributed SLAM and this application is that we assume that the robots know their \emph{global coordinates} within the area of deployment. They are only attempting to map it. 
Informally, the problem requires a set of robots to collaboratively agree on positioning of static \emph{obstacles} within a given area $D$, which any robot should avoid while moving in $D$.

\subsubsection{Preliminaries}
We first set up the terminology and assumptions to discuss our approach to this problem. We currently assume that the only sensors available for sensing obstacle are LIDAR based, and the robots are constrained to move in a 2-D space.

The mapping problem is defined over a (\emph{bounded}) domain $D$. In our problem setup, we assume $D$ is a rectangle in $\mathbb{R}^2$ given by $[x_1,x_2]\times [y_1,y_2]$.

\begin{definition}
A \emph{grid quantization} of a bounded domain $D$ is defined as a mapping $\qfunc:D \mapsto \qdom$, where $\qdom$ is a discrete set . If $\qdom$ is, for instance, $\mathbb{Z}\times \mathbb{Z}$, this can be viewed as an embedding of a 2D-lattice in $\mathbb{R}^2$. \rg{Consider also, that there is a set of ground robots $[N]$ in which each robot can can detect obstacles within radius $r$ of the current position of the robot.} 
\end{definition}

In theory, we can assume the existence of a \emph{ground truth} function $\world : D\mapsto \left\{0,1\right\}$, where $$\world(\Vec{x}) = \begin{cases}
1\ \mbox{if there is an obstacle at }\Vec{x}\\
0\ \mbox{otherwise}
\end{cases}
$$

This function then naturally extends to the quantization $Q$ of the domain $D$ as 
$\world_Q : Q \mapsto \left\{0,1\right\}$, where $$\world_Q(q) = \begin{cases}
1\ \Leftrightarrow \exists \Vec{x}\in D, \qfunc(\Vec{x}) = q \wedge \world(\Vec{x}) = 1 \\
0\ \mbox{otherwise}
\end{cases}
$$
We can then state the 2-d distributed mapping problem as follows. \begin{quote}
 {\em Given a grid quantization $\qfunc$ of a 2-d domain $D\subset \mathbb{R}^2$, a ground truth function $\world_Q$, construct a grid occupancy mapping, $\map: Q \mapsto \left\{1,0,-1\right\}$, where:
 \begin{flalign*}
 \map(q) = 1 &\Rightarrow \world_Q = 1\\
 \map(q) = 0 &\Rightarrow \world_Q = 0\\
 \world_q = 0 &\Rightarrow \map(q) = 0 \mbox{ or } \map(q) = -1\\
  \world_q = 1 &\Rightarrow \map(q) = 1 \mbox{ or } \map(q) = -1\\
 \end{flalign*}
 
 }
\end{quote}
%\begin{definition}
%Given a square $(i,j) \in G(D)$, its \emph{adjacent squares} are given by
%$\mathit{Adj}_{(i,j)} = \left\{(i^\prime, j^\prime) \mid i^\prime \in \left\{i - 1, i +1\right\}, j^\prime in \left\{j-1,j+1\right\} \right\} \cap G(D)$ .
%\end{definition} 

A robot partially constructs a grid occupancy function by assigning values to the grid squares in its \emph{sensed} area.

\rg{We assume that {\em if an obstacle is sensed in a grid square within the sensing area of the robot, then the square does contain an obstacle}. The point of this presentation isn't dealing with the issue of potentially false positives while identifying an obstacle.} 


\subsection{External (Library) Functions}
