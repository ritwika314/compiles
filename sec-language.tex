\section{\lgname Language Design}
\label{sec:language}

\chiao{
\refsect{semantics} <= 2 pages,
\refsect{memory} <= 1 page,
\refsect{module} <= 0.5 page
}

\subsection{Run-time System Abstraction and Parameters}

As mentioned in \refsect{overview}, the same \lgname program is expected to be run on a (distributed) system of robots,
and the robots communicate with each other through distributed shared memory.

\chiao{Introduce $\NMAX$, $\myuin$, $\UINS$, $\delta$.
If necessary, we can also make modules and other platform-specific things as parameters and refer to appendix.}
%
We have $\NMAX$ robots in the system each executing the same \lgname application program.
A synchronous \emph{round-by-round} execution,
where each round lasts for $\delta$ time, where $\delta >0$ is a platform specific execution parameter.


\subsection{Formal Syntax}\label{sec:syntax}

\reffig{partial-syntax} shows the partial grammar of \lgname syntax.
Each robot program consists of
\begin{inparaenum}[(a)]
\item declarations of the interfaces between the program and the controller modules,
\item declarations of shared and local program variables, and
\item events, consisting of preconditions and effects.
\end{inparaenum}
robot programs (rule \emph{Program}) can import a controller module.
The module import grammar production specifies the interface of the controllers:
it contains all input and output ports for actuators (\emph{APorts}) and sensors (\emph{SPorts}) that the program uses.
The program can also contain shared and local declarations.

\begin{enumerate}[i)]
\item \emph{Local program variables} record the state of the program.
\item \emph{Distributed shared variables} are used for coordination across robots.
      \textbf{allwrite} is a multi-writer variable which can be updated by any participating robot.
      Shared variables variables can also be single-writer (\textbf{allread}).
\item \emph{Sensor and actuator variables} are used to read from sensor ports and to write to actuator ports.
\end{enumerate}

There can be an initialization process which sets certain program variable values.
The program also includes events (rule \emph{Event}) which include a Boolean \textbf{pre}condition, which may be tagged \textbf{urgent},
and an \textbf{eff}ect, which includes statements.
The effect of an event may include the standard control flow constructs including a sequence of instructions,
conditional statements, as well as atomic blocks of statements for mutual exclusion, function calls and assignment statements.
The user is also allowed to define functions and abstract data types(which are tuples of the basic data types \lgname supports).
\chiao{Should we mention atomic block for shared variables?
Mutual exclusion is always an essential feature when shared variables are involved.
\lgname provides a locking mechanism using the keyword \textbf{atomic} to update the shared variable safely.}

In the syntax presented in \reffig{partial-syntax}, given an nonterminal \textit{NT},
{\it NT\textsuperscript{?}} means that it is optional in the syntax at that position,
{\it NT*} refers to zero or more occurrences,
and {\it NT\textsuperscript{+}} refers to one or more occurrences.
The expression $(E1\mid E2)$ denotes that one can use either $E1$ or $E2$.

\begin{figure}

\newcommand{\zeroone}{\textsuperscript{?}\ }
\newcommand{\zeromore}{*\ }
\newcommand{\onemore}{\textsuperscript{+}\ }
\newcommand{\vbar}{{\normalfont\ |\ }}
\newcommand{\mterm}[1]{{\normalfont \textbf{#1}}}
\newcommand{\delim}{\mterm{:\ }\xspace}

\itshape
\begin{tabular}{lrl}
    Program   & ::= & Def\zeromore Import\zeromore DeclBlock Init\zeroone Event\onemore \\
    Def       & ::= & TypeDef \vbar FuncDef                                             \\
    Import    & ::= & \mterm{using} identifier \delim SPorts APorts      \\
    SPorts    & ::= & \mterm{sensors} \delim VarDecl\onemore                            \\
    APorts    & ::= & \mterm{actuators} \delim VarDecl\onemore                          \\
              &     &                                                                   \\
    DeclBlock & ::= & AWDecl\zeroone ARDecl\zeroone LocalDecl\zeroone                   \\
    AWDecl    & ::= & \mterm{allwrite} \delim VarDecl\onemore                           \\
    ARDecl    & ::= & \mterm{allread} \delim ARVarDecl\onemore                          \\
    LocalDecl & ::= & \mterm{local} \delim VarDecl\onemore                              \\
    VarDecl   & ::= & Type identifier \vbar Type identifier \mterm{=} Val               \\
    ARVarDecl & ::= & Type identifier \mterm{[ $\NMAX$ ]}                               \\
              &     &                                                                   \\
    Init      & ::= & \mterm{init} \delim stmt\onemore                                  \\
    Event     & ::= & identifier \delim Precond Effect                                  \\
    Precond   & ::= & \mterm{urgent}\zeroone \mterm{pre} \delim expr                    \\
    Effect    & ::= & \mterm{eff} \delim stmt\onemore
\end{tabular}

\caption{Partial \lgname syntax rules.}\label{fig:partial-syntax}
\end{figure}


\subsection{Configurations}\label{sec:configs}

In each round, each robot performs an event.
The state update performed by a single robot executing an event is modeled as an transition of the state machine updating the program variables;
however, different events executed by the different robots may interleave.
In between the events of successive rounds, the program variables remain constant,
but {\em all\/} the sensor and actuator variables of all robots change continuously with time.
These are modeled as $\delta$-transitions that advance time as well as the sensor and actuator variables.

We now describe the system state, or \emph{system configurations} which we use to formalize \lgname semantics.

\paragraph{System Configurations.}

A {\em system configuration\/} with the parameter $\delta$ is a tuple
$\gconfig_\delta = (\lset_{i\in\UINS},{S},\tau,\turn)$, where

\begin{enumerate}[i)]
\item $\lset_{i\in\UINS}$ or $\lset$ in short is an indexed set of \emph{robot configurations}--one for each participating robot,
      where $\UINS$ is the known set of participating robots.
      $\lconfig{i}$ refers to the configuration of the $i$-th element, i.e., the $i$-th robot in the system.
\item ${S} : \Var \mapsto \Val$ is the {\em global context\/}, mapping all shared variable names to their values.
\item $\tau\in \nnreals$ is the {\em global time\/}.
\item $\turn\in\{\mathtt{prog,env}\}$ is a binary \emph{bookkeeping} variable determining whether  program or environment transitions are being processed.
\end{enumerate}

Bookkeeping variables are invisible in the language syntax, and only used in the semantics.


\paragraph{Robot Configurations.}

An \emph{robot configurations} is used to specify the semantics of each robot.
Given that $\mathbb{P}$ is the set of all production rules in the \lgname grammar,
$\Var$ is the set of variables, $\Val$ be is set of values that an expression in \lgname can evaluate to,
$\Cfield$ is the set of sensor and actuator ports of the controller being used,
the configuration of an robot is a tuple $\agnt = (p, {M},\cp,\turn)$, where

\begin{enumerate}[i)]
\item $P \in \mathbb{P}$ is the current syntactic production,
\item ${M} : \Var \mapsto \Val$ is its \emph{local context} mapping all variables in $P$ to robot local values.
\item $\cp : \Cfield \mapsto \Val$ is the mapping of sensor and actuator variables to values.
\item $\turn \in \{\mathtt{prog,env}\}$ is a bookkeeping variable indicating whether this robot should be executing a program or environment transition.
\end{enumerate}

The components of an robot configuration in the tuple $l$ are accessed
using the dot (``$.$'') notation, for example, $l.M\equiv \pi_2(l)$ and $l.w \equiv \pi_3(l)$.


\subsection{Formal Semantics}\label{sec:semantics}

%%semantic rule references
\newcommand{\EventRule}{\textsc{Event}\xspace}
\newcommand{\RunSysRule}{\textsc{RunSys}\xspace}
\newcommand{\EnvTransRule}{\textsc{EnvTrans}\xspace}
\newcommand{\RobotEnvToProgRule}{\textsc{RobotEnvToProg}\xspace}
\newcommand{\EnvToProgRule}{\textsc{EnvToProg}\xspace}
%%transition rules
\newcommand{\exprule}{\rightarrow_E\xspace}
\newcommand{\stmtrule}{\rightarrow_\mathit{stmt}\xspace}
\newcommand{\sysrule}{\rightarrow_\mathit{Env}\xspace}
\newcommand{\progtrans}{\rightarrow_\mathit{prog}\xspace}
\newcommand{\envtrans}{\rightarrow_\mathit{env}\xspace}

\newcommand{\lsetp}{\{\lconfig{i}^\prime\}}
\newcommand{\lsetpp}{\{\lconfig{i}^{\prime\prime}\}}
\begin{figure}
\scriptsize
\begin{mathpar}
    \inferrule*[Right=\EventRule]
    {
        \mathit{ev} = \textbf{pre } \mathit{Cond} \textbf{ eff }\mathit{Body} \land ev \in P \\
        \agnt= (P,{M},\cp,\mathtt{prog}) \land \agnt^\prime = (P,{M},\cp,\mathtt{env}) \land \mathit{eval(\mathit{Cond}, L.M)}
    }
    {\langle{S},\agnt, \cdot \rangle \stmtrule  \langle{S},\agnt^\prime, \mathit{Body} \rangle }

    \inferrule*[Right=\EnvTransRule]{
         \forall i \in \UINS, \lconfig{i}^\prime.\cp = \lconfig{i}.\mathit{f}(\lconfig{i}.\cp,\delta) \land \\
         \forall x \in \mathit{Keys}({S}),\lconfig{i}'.{M}[x \mapsto S[x]] \land \lconfig{i}.\turn = \mathtt{env}
    }
    { (\lset, {S}, \tau,\mathtt{prog})\rightarrow_G (\lsetp, {S}, \tau + \delta,\mathtt{env})}

    \inferrule*[Right=\RobotEnvToProgRule]
    {  \forall i \in \UINS, \lconfig{i}.\turn = \mathtt{env} \land \lconfig{i}^\prime.\turn = \mathtt{prog} }
    {  (\lset, S, \tau, \mathtt{env})\rightarrow_G (\lsetp, S, \tau, \mathtt{env})}

    \inferrule*[Right=\EnvToProgRule]
    {  \forall i \in \UINS, \lconfig{i}.\turn = \mathtt{prog} }
    {  (\lset, S,\tau, \mathtt{env})\rightarrow_G (\lset, S, \tau, \mathtt{prog})}

    \inferrule*[Right=\RunSysRule]
    {
         \forall i\in\UINS, (S,\lconfig{i},\lconfig{i}.p)\stmtrule(S^\prime,\lconfig{i}^\prime,p^\prime)\stmtrule\ldots\stmtrule (S^{\prime\prime},\lconfig{i}^{\prime\prime}, \cdot) \\
         \land\ \lconfig{i}^{\prime\prime}.\turn=\mathtt{env}
    }
    {(\lset, S, \tau,  \mathtt{prog})\rightarrow_G (\lsetpp, S^{\prime\prime}, \tau, \mathtt{prog})}
\end{mathpar}
\caption{Partial Semantic Rules for \lgname.}\label{fig:partial-semantics}
\end{figure}

\sayan{SM: The final ``theorem'' might be the bounded reachability soundness.}

For simplicity, we describe only part of semantic rules of \lgname that is above event level.
The detailed statement and expression level semantics of \lgname is standard.
The complete formalization of the semantics in \K is available from~\cite{}.


\paragraph{Event Semantics.}
\chiao{Need a complete rewrite for event level semantics.}
We provide the semantics for events in \lgname,
which will help us discuss the semantics of program and environment transitions.
First, we assume rules for statement semantics are of type
\[
\stmtrule \subseteq (\pws \times \pwl\times \pwstmt \cup \{\cdot\}) \times \wp(\pws\times \pwl \times \pwstmt \cup \{\cdot\}),
\]
where $\pwstmt$ refers to the set of all possible statements allowed by language syntax,
and the symbol `$\cdot$' indicates an ``empty" statement, which does not affect the configurations.
The update relation takes as input a tuple of (1) an robot configuration, (2) a global context, and (3) a statement, and maps it to a set of such tuples.

Rule~\EventRule in \reffig{partial-semantics} shows that an event can be executed,
the $\turn$ of the robot is set to $\mathtt{env}$ indicating that after this execution, an environment transition occurs.
The system can display non deterministic behaviors arising from different robots executing their events in different orders.


\paragraph{Environment Robot Transition.}

The advancement of time and environment transitions govern the changes in the system configuration.
The rewrite rule is a mapping from an initial system configuration to a set of configurations.
It has the type
$$\rightarrow_G\ \subseteq (\pwl\times \pws \times \nnreals \times \{\mathtt{prog,env}\}) \times \wp(\pwl\times\pws \times \nnreals\times \{\mathtt{prog,env}\}) $$

First, we present the semantics of executing the events for each robot.
A \lgname program can be seen as sequences of $\stmtrule$ rules, which determine event executions followed by an environment transition.
To express this, we define a rule that shows the the changes in the configuration of the overall system due to all the robots executing their program just before an environment transition is applicable.

Rule~\RunSysRule expresses that starting from a global configuration $c = (\lset, S, \tau, \env)$,
each robot $i$ with local configuration $\lconfig{i}$ processes its program $P$ using a sequence of $\stmtrule$ rewrites,
until its event is executed,
and its $\turn$ set to $\mathtt{env}$ at the end of the event execution.
Overall, the system goes from a configuration $c$ to $c^{\prime\prime}= (\lsetpp, S^{\prime\prime}, \tau, \env)$,
with possibly different robot configurations and global context depending on
whether any of the events executed resulted in writes to shared variables.

Suppose the function $f:\mathit{Sens} \times \Val \times \nnreals \mapsto \Val$ captures the behavior of the controller,
and can be used to update the sensor ports after time $\delta$.
Rule~\EnvTransRule shows the semantics of the system configuration after rule~\RunSysRule.
\sayan{This formalization allows the ports to behave arbitrarily over $\delta$-transitions. In order to establish invariant properties of applications, therefore, we will need to constrain the behavior of the sensor and actuator ports with additional assumptions.}

Rule~\RobotEnvToProgRule is the semantic rule for setting the $\mathit{turn}$ of each robot back to $\mathtt{prog}$ from $\mathtt{env}$ after the environment transition has been completed. The semantics synchronizes the program transitions of each robot, ensuring that the event executions for each happen every $\delta$ time.


Rule~\EnvTransRule captures the fact that the global context $S$ is copied into local context $\lconfig{i}.M$ of each robot $i$,
thus ensuring that all robots have consistent shared variable values before the next program transition.
After that, rule~\EnvToProgRule changes the turn of each robot back to program.
In an actual execution, the controller would run the program on hardware,
whose sensor ports evolve for $\delta$ time between program transitions.

%
% Then, for every order of program transitions in $p$, the algorithm uses the \lgname semantics to compute $C^\prime$, the set of all configurations reached by the system during that round of program transitions. The algorithm first checks $\mathit{inv}$ is valid for configurations in $C^\prime$, or that the negation of $\mathit{inv}$ is unsatisfiable, using the procedure $\mathit{Sat}$. If it finds an unsafe configuration $c$, then it returns `unsafe' along with $c$.
%

We use bookkeeping variables to ensure that all robots have their turn set to \texttt{env} before the system environment transition.
We also ensure that an robot has updated its sensor ports after the environment transition,
to implement the rule~\RobotEnvToProgRule.
Once all the robots in the system are ready to perform the next program transition,
the rulee~\EnvToProgRule is implemented as follows.
If the number of robots which have set their $\mathit{turn}$ to $\mathit{env}$ is the same as the number of all robots in the system,
then the system sets its turn from $\mathit{Env}$ to $\mathit{Prog}$.


\subsection{Synchronous Distributed Shared Memory}
\label{sec:memory}

\chiao{
Precisely describe how this can be achieved by synchronous communication given a $\delta$ time bound.
Discuss why this abstraction over message passing with time delays is acceptable/reasonable}

%\subsubsection{Shared memory updates}
%
% The set of all copies of the local copies shared variables can be seen as the \emph{distributed shared memory}. The correctness of a program relies on consistent values of the robots' local values of shared variables. When an robot writes to a variable, it updates its local copy and our implementation of the $\lgname$ framework uses message passing to inform the other robots of the change.
%%

\subsubsection{Synchronization and consistency}
\rg{robot local states and propagation over messages.}
\rg{We assume that the event transitions are computational steps, and take zero logical time, whereas the $\delta$-transitions denote the evolution of the sensor and the actuator ports with time, and take $\delta$ time.}
The following are the timing assumptions on \lgname programs.
\begin{assumption} A program step has zero logical execution time.
\end{assumption}
This assumption is reasonable if the time taken to complete a program transition step is negligible compared to $\delta$.  The $\lgname$ middleware ensures that the participating robots begin executing their events synchronously.

\begin{assumption}
    \label{shared}
    Shared memory updates are propagated to all robots within one round. That is, given a state $\vs\in C$, for every  $i,j \in [N]$, for a shared variable $v$, $\vs.v_i = \vs.v_j$.
\end{assumption}
The \lgname middleware uses message passing to implement shared memory, and compared to $\delta$, the time taken to observe a shared memory update as a received message from the time that it is sent is much smaller. We therefore can assume that in this setting, the shared memory semantics of \lgname wherein an update is visible in the next round of program transitions, is a reasonable implementation deliverable.



\subsection{Specify Constraints over Modules}
\label{sec:module}
\chiao{As mentioned in \refsect{semantics}, the assumptions over modules will be directed by the target invariant/property.
What does \lgname provide to help identify the assumptions?}
