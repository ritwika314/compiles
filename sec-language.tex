\section{\lgname Language Design}
\label{sec:language}

\subsection{Synchronous Run-time System }

As mentioned in \refsect{overview}, instances of the same \lgname program runs on a distributed collection of $\NMAX$ robots. The robots communicate with each other through distributed shared memory.
%
%\chiao{Introduce $\NMAX$, $\myuin$, $\UINS$, $\delta$.
%If necessary, we can also make modules and other platform-specific things as parameters and refer to appendix.}
%
%We have  robots in the system.
The execution of the \lgname program advances in a synchronous, \emph{round-by-round} fashion, where each round lasts for $\delta$ time, and $\delta >0$ is a platform specific execution parameter. During this period, the robots compute, move, and communicate.


\subsection{Formal Syntax}\label{sec:syntax}

\reffig{partial-syntax} shows the partial grammar of \lgname syntax.
Each robot program consists of
\begin{inparaenum}[(a)]
\item declarations of the interfaces between the program and the controller modules,
\item declarations of shared and local program variables, and
\item events, consisting of preconditions and effects.
\end{inparaenum}
Robot programs (rule \emph{Program}) can import a controller module.
%
\marginpar{\scriptsize\sayan{one or more?}}
%
The module import grammar production specifies the interface of the controllers:
it contains all input and output ports for actuators (\emph{APorts}) and sensors (\emph{SPorts}) that the program uses.
The program can also contain shared and local declarations.

\begin{enumerate}[(i)]
\item \emph{Local program variables} record the state of the program.
\item \emph{Distributed shared variables} are used for coordination across robots. All shared variables can be read by all participating robots; an
      \textbf{allwrite} variable can be written by any participating robot; while an 
      \textbf{allread} variable variable can written by a single-writer.
\item \emph{Sensor and actuator variables} are used to read from sensor ports and to write to actuator ports.
\end{enumerate}
%
\marginpar{\scriptsize\sayan{are sensor ports different from sensor variables?}}
%

There can initialization \sayan{statements} which set certain program variable values.
The main body of the program is a sequence of  events (rule \emph{Event}) which include a Boolean \textbf{pre}condition
and an \textbf{eff}ect.
The effect of an event may include the standard control flow constructs including a sequence of instructions, conditional statements, as well as atomic blocks of statements for mutual exclusion, function calls, and assignment statements.
The user can also define functions and abstract data types (tuples of the basic data types).
\chiao{Should we mention atomic block for shared variables?}
\sayan{add the atomic keyword in the syntax and add a sentence in the description.}
Mutual exclusion is always an essential feature when shared variables are involved.
\lgname provides a locking mechanism using the keyword \textbf{atomic} to update the shared variable safely.

In the syntax presented in \reffig{partial-syntax}, given an nonterminal \textit{NT},
{\it NT\textsuperscript{?}} means that it is optional in the syntax at that position,
{\it NT*} refers to zero or more occurrences,
and {\it NT\textsuperscript{+}} refers to one or more occurrences.
The expression $(E1\mid E2)$ denotes that one can use either $E1$ or $E2$.

\begin{figure}

\newcommand{\zeroone}{\textsuperscript{?}\ }
\newcommand{\zeromore}{*\ }
\newcommand{\onemore}{\textsuperscript{+}\ }
\newcommand{\vbar}{{\normalfont\ |\ }}
\newcommand{\mterm}[1]{{\normalfont \textbf{#1}}}
\newcommand{\delim}{\mterm{:\ }\xspace}

\itshape
\begin{tabular}{lrl}
    Program   & ::= & Def\zeromore Import\zeromore DeclBlock Init\zeroone Event\onemore \\
    Def       & ::= & TypeDef \vbar FuncDef                                             \\
    Import    & ::= & \mterm{using} identifier \delim SPorts APorts                     \\
    SPorts    & ::= & \mterm{sensors} \delim VarDecl\onemore                            \\
    APorts    & ::= & \mterm{actuators} \delim VarDecl\onemore                          \\
              &     &                                                                   \\
    DeclBlock & ::= & AWDecl\zeroone ARDecl\zeroone LocalDecl\zeroone                   \\
    AWDecl    & ::= & \mterm{allwrite} \delim VarDecl\onemore                           \\
    ARDecl    & ::= & \mterm{allread} \delim ARVarDecl\onemore                          \\
    LocalDecl & ::= & \mterm{local} \delim VarDecl\onemore                              \\
    VarDecl   & ::= & Type identifier \vbar Type identifier \mterm{=} Val               \\
    ARVarDecl & ::= & Type identifier \mterm{[ $\NMAX$ ]}                               \\
              &     &                                                                   \\
    Init      & ::= & \mterm{init} \delim stmt\onemore                                  \\
    Event     & ::= & identifier \delim Precond Effect                                  \\
    Precond   & ::= & \mterm{pre} \delim expr                                           \\
    Effect    & ::= & \mterm{eff} \delim stmt\onemore
\end{tabular}

\caption{Partial \lgname syntax rules.}\label{fig:partial-syntax}
\end{figure}


\subsection{Koord Semantics}
\label{sec:configs}

The semantics of a \lgname program execution is based on synchronous rounds divided into {\em event transitions\/} and {\em environment transitions\/} that update the {\em system configuration.\/}
In each round, each robot performs \sayan{at most one} event.
The update performed by a single robot executing an event is modeled as an transition of updating the program variables;
however, different events executed by the different robots may interleave.
In between the events of successive rounds, the program variables remain constant,
but the sensor and actuator variables of all robots change continuously with time.
\sayan{Need to choose the words carefully here. We should discuss. Whether the variables change value continuously or discretely is a modeling question and what we want to analyze.}
These are modeled as environment transitions that advance time as well as the sensor and actuator variables.

We now describe the system state, or \emph{system configurations} which we use to formalize \lgname semantics.

\paragraph{System Configurations.}

A {\em system configuration\/} with the parameter $\delta$ is a tuple
$\gconfig_\delta = (\lset_{i\in\UINS},{S},\tau,\turn)$, where

\begin{enumerate}[i)]
\item $\lset_{i\in\UINS}$ or $\lset$ in short is an indexed set of \emph{robot configurations}--one for each participating robot,
      where $\UINS$ is the known set of participating robots.
      $\lconfig{i}$ refers to the configuration of the $i$-th element, i.e., the $i$-th robot in the system.
\item ${S} : \Var \mapsto \Val$ is the {\em global context\/}, mapping all shared variable names to their values.
\item $\tau\in \nnreals$ is the {\em global time\/}.
\item $\turn\in\{\prog,\env\}$ is a binary \emph{bookkeeping} variable determining whether  program or environment transitions are being processed.
\end{enumerate}

Bookkeeping variables are invisible in the language syntax, and only used in the semantics.


\paragraph{Robot Configurations.}

A \emph{robot configurations} is used to specify the semantics of each robot.
Given that $\mathbb{P}$ is the set of all possible lists of statements in \lgname grammar,
$\Var$ is the set of variables, $\Val$ be is set of values that an expression in \lgname can evaluate to,
and $\Cfield$ is the set of sensor and actuator ports of the controller being used,
the configuration of an robot is a tuple $\agnt = ({M},\cp,\turn)$, where

\begin{enumerate}[i)]
\item ${M} : \Var \mapsto \Val$ is its \emph{local context} mapping all variables in $P$ to robot local values.
      Do note that $M$ also includes a copy of shared variable values.
\item $\cp : \Cfield \mapsto \Val$ is the mapping of sensor and actuator variables to values.
\item $\turn \in \{\prog,\env\}$ is a bookkeeping variable indicating whether this robot should be executing a program or environment transition.
\end{enumerate}
The components of an robot configuration in the tuple $l$ are accessed
using the dot (``$.$'') notation, for example, $l.M\equiv \pi_2(l)$ and $l.w \equiv \pi_3(l)$.

Further, the set of events for each robot is denoted as $\Event$,
and the controller module is modeled as a black-box functions
$f: [\Cfield \mapsto \Val] \times \nnreals \mapsto [\Cfield \mapsto \Val]$.
That is, given old sensor and actuator values as well as a period of continuous time,
$f$ evaluates the physical dynamics and returns new values for all sensor and actual ports.


\subsection{Formal Semantics}\label{sec:semantics}

%%semantic rule references
\newcommand{\SelectEventRule}{\textsc{SelectEvent}\xspace}
\newcommand{\SkipEventRule}{\textsc{SkipEvent}\xspace}
\newcommand{\EndEventRule}{\textsc{EndEvent}\xspace}
\newcommand{\EventTransRule}{\textsc{EventTrans}\xspace}
\newcommand{\EndProgTransRule}{\textsc{EndProgTrans}\xspace}
\newcommand{\RobotEnvRule}{\textsc{RobotEnv}\xspace}
\newcommand{\EnvTransRule}{\textsc{EnvTrans}\xspace}
%%transition rules
\newcommand{\exprule}{\rightarrow_E\xspace}
\newcommand{\stmtrule}{\rightarrow_\mathit{stmt}\xspace}
\newcommand{\sysrule}{\rightarrow_\mathit{Env}\xspace}
\newcommand{\progtrans}{\rightarrow_\mathit{prog}\xspace}
\newcommand{\envtrans}{\rightarrow_\mathit{env}\xspace}
%%
\newcommand{\SelectEvent}{\ensuremath{\mathtt{\oplus}}\xspace}
\newcommand{\EndEvent}{\ensuremath{\mathtt{\cdot}}\xspace}

\newcommand{\lsetp}{\{\lconfig{i}^\prime\}}
\newcommand{\lsetpp}{\{\lconfig{i}^{\prime\prime}\}}
\begin{figure}
\scriptsize
\begin{mathpar}
    \mprset{flushleft}
    \inferrule*[leftskip=1.5cm, Right=\SelectEventRule]
    {
        \agnt.\turn = \prog
        \land ``\mathit{Name}\textbf{: pre: } \mathit{Cond} \textbf{ eff: }\mathit{Body}" \in \Event
        \land \mathit{\EvalExpr{\mathit{Cond}}}
    }
    {\langle{S}, \agnt, \SelectEvent \rangle \stmtrule  \langle{S}, \agnt, \mathit{Body} \rangle }
    \\

    \inferrule*[Right=\SkipEventRule]
    {}
    {\langle{S}, \agnt, \SelectEvent \rangle \stmtrule  \langle{S}, \agnt, \EndEvent \rangle }    \\

    \inferrule*[Right=\EndEventRule]
    {}
    {\langle{S},({M},\cp,\prog), \EndEvent \rangle \stmtrule  \langle{S},({M},\cp,\env), \EndEvent \rangle }

    \inferrule*[Right=\EventTransRule]
    {
        \exists i \in \UINS, \langle S,\lconfig{i}, \SelectEvent \rangle \stmtrule\ldots\stmtrule
        \langle S^{\prime},\lconfig{i}', \EndEvent\rangle \\
        \land\ \lconfig{i}.\turn = \prog \land \lconfig{i}^\prime.\turn = \env
    }
    {(\lset, S, \tau, \prog)\rightarrow_G (\lsetp, S^{\prime}, \tau, \prog)}

    \inferrule*[Right=\EndProgTransRule]
    {
        \forall i \in\UINS, \lconfig{i}.\turn=\env
    }
    {(\lset, S, \tau, \prog)\rightarrow_G (\lset, S, \tau, \env)}
    \\

    \inferrule*[leftskip=1cm, Right=\RobotEnvRule]
    {
        \forall x \in \mathit{Keys}({S}),M' = {M}[x \mapsto S[x]] \land \cp' = \mathit{f}(\cp,\delta)
    }
    {  \langle S, (M, cp, \env) \rangle \envtrans \langle S, (M', cp', \prog) \rangle}

    \inferrule*[Right=\EnvTransRule]{
        \forall i \in \UINS, \langle S, \lconfig{i} \rangle \envtrans \langle S, \lconfig{i}^\prime \rangle \\\\
        \land \lconfig{i}.\turn = \env \land \lconfig{i}^\prime.\turn = \prog
    }
    { (\lset, {S}, \tau,\env)\rightarrow_G (\lsetp, {S}, \tau + \delta,\prog)}

%    \inferrule*[Right=\RobotEnvToProgRule]
%    {  \forall i \in \UINS, \lconfig{i}.\turn = \env \land \lconfig{i}^\prime.\turn = \prog }
%    {  (\lset, S, \tau, \env)\rightarrow_G (\lsetp, S, \tau, \env)}
%
%    \inferrule*[Right=\EnvToProgRule]
%    {  \forall i \in \UINS, \lconfig{i}.\turn = \prog }
%    {  (\lset, S,\tau, \env)\rightarrow_G (\lset, S, \tau, \prog)}
\end{mathpar}
\caption{Partial Semantic Rules for \lgname.}\label{fig:partial-semantics}
\end{figure}

\sayan{SM: The final ``theorem'' might be the bounded reachability soundness.}

For simplicity, we describe only part of semantic rules of \lgname that is above event level.
The detailed statement and expression level semantics of \lgname is available in~\cite{}.

\paragraph{Per Robot Semantics.}
First, we present the semantics of executing the events for each robot.
which will help us discuss the semantics of the whole system.
Following~\cite{}, we know that all rules for statement semantics are of type
\[
\stmtrule \subseteq (\pws \times \pwl\times (\pwstmt^+ \cup \{\SelectEvent\})) \mapsto \wp(\pws\times \pwl \times \pwstmt^*),
\]
where $\pwstmt$ refers to the set of all possible statements allowed by language syntax.
This relation takes as input a tuple of (1) a global context, (2) an robot configuration, and (3) a sequence of statements or \SelectEvent,
and maps it to a set of such tuples.
The symbol `\SelectEvent' is a symbol not in \lgname to denote nondeterministic selection of events,
and we use `\EndEvent' to indicate an ``empty" sequence.

Rule~\SelectEventRule in \reffig{partial-semantics} shows that any event may be executed when the precondition $Cond$ is evaluated to true,
and by replacing \SelectEvent with the event effect $\mathit{Body}$, it ensures only one event is selected and executed.
The event effect is then executed following the semantics of each statement in $\mathit{Body}$.
Rule~\SkipEventRule allows the robot to skip the event completely.
At the end of the event, the sequence of statements becomes empty~`\EndEvent'.
Rule~\EndEventRule then makes sure the $\turn$ of the robot is set to $\env$ indicating that
an environment transition will occur afterwards.

Similarly, we define the semantics of how each robot interacts with environment including other robots.
The environment transition rule is of type
\[
\envtrans \subseteq (\pws \times \pwl) \mapsto \wp(\pws\times \pwl),
\]
which takes a global context and a robot configuration as input.
Rule~\RobotEnvRule simply states that the new local context $M'$ is
old local context $M$ updated with the global context $S$;
thus ensuring that all robots have consistent shared variable values before the next program transition.
New sensor readings $\cp'$ is then obtained by evaluating the black-box dynamics $f$ with time $\delta$.
In an actual execution, the controller would run the program on hardware,
whose sensor ports evolve for $\delta$ time between program transitions.
\sayan{%
This formalization allows the ports to behave arbitrarily over $\delta$-transitions.
In order to establish invariant properties of applications;
therefore, we will need to constrain the behavior of the sensor and actuator ports with additional assumptions.
}%
Finally, the $\turn$ of the robot is set back to $\prog$.


\paragraph{Global Semantics.}

With the event semantic for each robot, we can then define the execution for the distributed \lgname program.
The rewrite rule is a mapping from an initial system configuration to a set of configurations.
It has the type
\[
\rightarrow_G\ \subseteq \pwg \mapsto \wp(\pwg),
\]
where $\pwg$ is the set of all possible global configurations.

Rule~\EventTransRule expresses that starting from a global configuration $\gconfig = (\lset, S, \tau, \prog)$,
a robot $i$ with the configuration $\lconfig{i}$ starts by selecting an enabled event,
executes the event via a sequence of $\stmtrule$ rewrites,
and sets its own $\turn$ to $\env$ at the end of the event execution.
The system goes from a configuration $\gconfig$ to $\gconfig^{\prime}= (\lsetp, S^{\prime}, \tau, \prog)$,
with possibly different robot configurations and global context depending on
whether any statement executed resulted in writes to shared variables.
The system can display nondeterministic behaviors arising from different robots executing their events in different orders.
After all robots enter the $\env$ turn, rule~\EndProgTransRule sets the global $\turn$ from $\prog$ to $\env$
indicating the end of program transition, and an environment transition will occur afterwards.

Rule~\EnvTransRule shows the semantics of the system configuration after rule~\EndProgTransRule.
This rule synchronizes the environment transitions of each robot and
ensure that the global time $\tau$ advances to $\tau + \delta$.


\subsection{Synchronization and Consistency}
\label{sec:sync}

Following our semantic rules in \refsect{semantics},
careful readers would notice all event transitions of \lgname program takes \emph{zero} time,
whereas the environment transitions take $\delta$ time for the evolution of the sensor and the actuator ports
together with the update of the local context from the global context.
In other words, we assume the 
In this section, we discuss the design rationale of this abstraction

%\subsubsection{Shared memory updates}
%
% The set of all copies of the local copies shared variables can be seen as the \emph{distributed shared memory}. The correctness of a program relies on consistent values of the robots' local values of shared variables. When an robot writes to a variable, it updates its local copy and our implementation of the $\lgname$ framework uses message passing to inform the other robots of the change.
%%

\rg{robot local states and propagation over messages.}

The following are the timing assumptions on \lgname programs.
\begin{assumption}
    A program transition has zero logical execution time, and an environment transition has $\delta$ execution time.
\end{assumption}
This assumption is reasonable if the time taken to complete a program transition step is negligible compared to $\delta$.  The $\lgname$ middleware ensures that the participating robots begin executing their events synchronously.

\begin{assumption}
    \label{shared}
    Shared memory updates are propagated to all robots within one round. That is, given a state $\vs\in C$, for every  $i,j \in \UINS$, for a shared variable $v$, $\vs.v_i = \vs.v_j$.
\end{assumption}
The \lgname middleware uses message passing to implement shared memory, and compared to $\delta$, the time taken to observe a shared memory update as a received message from the time that it is sent is much smaller. We therefore can assume that in this setting, the shared memory semantics of \lgname wherein an update is visible in the next round of program transitions, is a reasonable implementation deliverable.

