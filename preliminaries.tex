\section{Koord Software Stack}
\label{sec:software}

\subsection{Runtime system}



To run a $\lgname$ program (hardware or simulation), the user has to provide a configuration file, with
\begin{inparaenum}
    \item the number of agents,
    \item in case of simulation, the initial positions of the agents and the length of the simulation and
    \item in case of hardware deployment their IP addresses,
    and the localization system.
\end{inparaenum}

\subsection{Key environment assumptions}


\subsubsection{Periodic event execution semantics}


\subsubsection{Shared variable implementation over message passing}


\subsubsection{Known set of participants}
\subsubsection{Portability and heterogeneity}


\subsection{Simulator}
\subsubsection{gazebo environment}
\subsubsection{car model}
\subsubsection{lidar}
\subsubsection{positioning}
\subsubsection{sampled sensing}
\subsubsection{synchronization issues}

\subsection{Formal semantics of Koord}
\label{sec:semantics}

The (distributed) system of robots  executing the \dmap application written in $\lgname$ can be viewed as a nondeterministic, state machine automaton~\cite{TIOAmon, Mitra07PhD}. The detailed statement-level semantics of $\lgname$ has been developed in the $\mathbb{K}$ framework and will appear elsewhere. For the purpose of the analysis here, we briefly describe the ``big-step'' semantics of Koord which allows all the statements in an event of a single agent to be executed as an instantaneous transition. 

Suppose we have $N$ agents or robots in the system each executing the same Koord application program. As mentioned earlier Koord middleware enforces a synchronous  \emph{round-by-round} execution, where each round lasts for $\delta$ time, where $\delta >0$ is a platform specific execution parameter. 
%
In each round, each robot performs an  event.
The state update performed by a single robot executing an  event is modeled as an  transition of the state machine updating the program variables, however,  different events executed by the different robots may interleave. In between the events of successive rounds, the program variables remain constant, but {\em all\/} the \sayan{sensor and actuator variables} of all the robots  change continuously with time.  These are modeled as the $\delta$-transitions that advance time as well as the \sayan{sensor and actuator variables}.

%
Let the set of all program variables in the $\lgname$ application be $\Var$, and the set of all the sensor and actuator ports be $\mathit{Port}$. 
%
The sets of variables and ports of an individual agent $i$ are denoted by $\Var_i$ and  $\mathit{Port}_i$.
%
A {\em valuation\/} of $\Var \cup \Port$ maps the names of the variables and ports to their types. 
We denote valuations using boldface letter like $\vs, \vs_1, \vs'$, etc. 
%
Given a valuation $\vs$, the value of a subset of  variables (or ports) $X$ is denoted by $\vs.X$. For example, the  valuation of all the variables of agent $i$ is $\vs.\Var_i$.
%
Let $\mathit{Event}_i$ be the set of event names for the application program of agent $i$. 
%
\sayan{For example, in \dmap ...vars, ports, events. }

%
%values that the variables can take is $\Val$, the \emph{state} of a robot $i$ is a tuple $$s_i = ( M, cp), \mbox{ where}$$
%
For the purpose of this paper, we define the  semantics of the overall system with $N$ agents as discrete transition system $\A = (Q, Q_0, A, \D)$,
where 
(1) $Q$ is the set of valuations of all the variables in $\Var$ and all the ports $\mathit{Port}$, 
(2) $Q_0 \subseteq Q$ is the set of initial values of the variables and port. All variables and ports have to be initialized, 
(3) $A = \{\delta\} \cup \left( \cup_{i \in [N]} \mathit{Events}_i \right)$ is the set of transition labels, and
(4) $D \subseteq Q \times A \times Q$ is a set of discrete transitions. There are two types of transitions, namely:
\begin{enumerate}
	\item {\em event transition}: Any $a \in \Event_i$ for some $i \in [N]$, and  $(\vs,a,\vs') \in \D$ iff (i) $\vs'.\Var_i$ is obtained by applying the transition relation of $a$ to $\vs.\Var_i$, and 
		(ii) For all $j \neq i$, 
		$\vs'.\Var_j = \vs.\Var_j$.
	\item {\em $\delta$-transition}: $a = \delta$, and $(\vs,a,\vs') \in \D$ iff (i) $\vs'.\Var = \vs.Var$. 
\end{enumerate}
\sayan{This formalization allows the ports to behave arbitrarily over $\delta$-transitions. In order to establish invariant properties of applications,  therefore, we will need to constrain the behavior of the sensor and actuator ports with additional assumptions.
}
%
%of each robot evolve to the 	controllers driving the robot according to the actuators that may have been set in the event. The program and sensor variables of the robot can be seen as the state variables for each robot.


%\begin{enumerate}
%    \item $M : \Var \mapsto \Val$ is the mapping of all program variables in the application known by the robot to their values.
%    \item $cp : \Var \mapsto \Val$ is the mapping of actuator and sensor variables to their values.
%\end{enumerate}
%The components of the tuple $s_i$ are accessed using the dot $`.'$ notation, for instance, $s_i.M$, etc. The value of a program variable $v$ at a state $s_i$ is denoted by $s_i.M.v$.

%Given an $\lgname$ program with a set of events $E$, the set of states of an robot $S$, we define a transition $\mathit{trans}: S \times E \mapsto 2^S$ as a non-deterministic mapping from a state to a set of states reached by a robot after a round in which a given event is executed.

Execution ${\bf  s}_0, {\bf s}_1$, execution. 

Reachable states, invariants of the big state machine. 

${\bf s},{\bf  s'}$ state of the whole system. 
${\bf s}.variablenme_i$ state of the $i,j$ robot. 

\marginpar{\scriptsize\sayan{Introduce the time-transitions, give it a name and say that it updates the ports.}}



\section{Formal modeling and analysis}
\label{sec:formal}

In this section, we present the formal definition of the distributed mapping problem. Then we develop a state machine model of the \dmap application executing in the physical environment, and finally, using this model we show that the it meet the key requirements of the mapping problem. One of the outcomes of this analysis is the identification of a list of precise 
 assumptions of sensors, CyPhyHouse middleware implementation, quantization, and \sayan{fill in}, that need to be checked separately for obtaining end-to-end, system-level guaranteed. 
 
\subsection{Formal definition of mapping problem}
\label{sec:prelims}

\begin{figure*}[t]
\newcommand{\grid}[2]{\ensuremath{\langle#1,#2\rangle}}

\tikzstyle{grid map} = [
scale=0.4,
every node/.style = {font=\scriptsize,align=center},
]

\input{figs/quantized-map.tex}
\input{figs/consistent-map.tex}

\caption{$D = [0.0,10.0]^2 \subset \mathbb{R}^2$, $Q=\{0.5, \cdots, 9.5\}^2 \subset \mathbb{Q}^2$, for example, $\world_Q(\grid{5.5}{0.5}) = 0$ and $\world_Q(\grid{6.5}{0.5}) = 1$}
\end{figure*}

\paragraph{Notations.}
$\mathbb{R}, \mathbb{Q},\mathbb{N}$, and $\mathbb{B}$ denote the sets of real, rational, natural, and boolean numbers.
For any $N \in \mathbb{N}$, $[N]$ is the set $\{1,2,\ldots,N\}$.
%
Given any function $f:A \rightarrow S$, we denote the {\em domain\/} of $s$ as $\domain(f) = A$.
%
Given a subset $A' \subseteq \domain(f)$, 
    the restriction of $f$ to $A'$, is written as $f \lceil A'$, and it is defined as the function $g:A' \rightarrow S$ such that for all $a \in A'$, $g(a) = f(a)$.

\paragraph{Mapping problem.}
The mapping problem is defined in terms of the following parameters.
\begin{enumerate}
	\item A positive integer $N$ which is the number of participating agents or robots. We will assume that the number and identity of agents is known. foe convenience, here we assume that the robots have unique identifiers from the set $[N]$.
	\item A domain $D$ which is bounded rectangle $[a_1,a_2]\times [b_1,b_2]$ in $\mathbb{R}^2$ corresponding to the physical arena.
	\item A \emph{ground truth} function $\world : D\mapsto \left\{0,1\right\}$ that gives the actual  occupancy of obstacles in this arena. That is, $\forall \Vec{x} \in D$, 
\begin{align}
\world(\Vec{x}) = 
		\left\{
		\begin{array}{ll}
			1 & \mathit{if}\ \Vec{x} \ \mathit{is \ occupied}\\
			0 & \mathit{otherwise}.
		\end{array}
		\right.
\end{align}
	\item A set $\qdom \subseteq D \cap \mathbb{Q}^2$ which is a quantized representation of $D$.
	\item A Koord program variable, let us call it $\mathit{map}_i$, for each robot $i \in [N]$, that stores the $\qdom$-quantized, shared map.
\end{enumerate}
%%
%%
For the sake of specificity, we assume that $\qdom$ is a $(n_x\times n_y)$-grid representation of $D$ for some resolution constants $n_x,n_y \in \mathbb{N}$. That is, $\qdom = \{q_{ij} \in \mathbb{Q}^2\}_{i\in [1..n_x], j\in [1..n_y]}$ such that every $q_{ij}$ uniquely represents a disjoint $[x_i, x_{i+1}] \times [y_j, y_{j+1}]$ in $D$.
%
%\begin{definition}
    The \emph{quantization function}  $\qfunc:D \mapsto \qdom$ maps points in $D$ to their quantized versions. That is $\qfunc(\Vec{x}) = q_{ij}$ iff $\Vec{x} \in [x_i, x_{i+1}] \times [y_j, y_{j+1}]$.
The inverse is defined accordingly: $\qinv(q_{ij}) =  [x_i, x_{i+1}] \times [y_j, y_{j+1}]$ for any $q_{ij} \in Q$. 
%\end{definition}
%
The quantization defines a quantized version of the world $\world_Q : \qdom \mapsto \left\{0,1\right\}$, where
$$\world_Q(q) = \begin{cases}
        1\ \Leftrightarrow \exists \Vec{x}\in \qinv(q), \world(\Vec{x}) = 1, \\
        0\ \mbox{otherwise}.
\end{cases}
$$
%

For each robot $i$, the program variable $\mathit{map}_i$ will ideally store a qunantized restriction of $\world$. That is, the type of this variable will be $\mathit{map}_i: Q' \rightarrow \mathbb{B}$, for some $Q' \subseteq Q$. 
%
Finally, we will assume that each robot $i$ occupies space within the arena $D$ and it's position is available from a sensor port $\mathit{pos}_i$ which takes values in $D$. 

Now we can formally state the desirable requirements of the mapping application.
\begin{enumerate}
	\item {\em (Individually sound)} Always, each robot's map is a quantized restriction of the ground truth. That is, $\map_i: Q_i \mapsto \mathbb{B}$, where $Q_i\subseteq Q$ and  $\map_i(q) = \world_Q(q)$ for every $q\in Q_i$.
	\item {\em (Consistent)\/} Always, robot maps are consistent. That is, for any two robots $i,j \in [N]$,   $\map_i(q) = map_j(q)$  for any  $q\in \domain(\map_i)  \cap \domain(map_j)$.
	\item {\em (Safe location)\/} Always, each robot is located in a part of the arena that is known to be free. 
	%That is, for any  $i \in [N]$,   $\pos_i \in  = map_j(q)$  for any  $q\in \domain(\map_i)  \cap \domain(map_j)$.

	\item {\em (Eventual completeness)} Eventually, the constructed maps cover $\world$. That is, for each robot $i\in [N], \domain(\map_i) = Q$.
\end{enumerate}

\marginpar{\scriptsize\sayan{Say that we will prove 1,2 and why 3 is in general hard world may be partitioned. Path planning might hard. Quantization may be too coarse for finding safe paths...}}

\subsection{Assumptions}
\label{sec:formal:sensing}


\subsubsection{Perception}

\subsubsection{Planning and actuation}

\subsubsection{Running time of Koord programs}

\marginpar{\scriptsize\sayan{MAke this a list of {\bf Assumptions} with discussion on why they hold, or what they mean in English.}}

\begin{definition}
   Given a robot at a position $\Vec{x}\in D, \qfunc{\Vec{x}} = q$, we define the \emph{sensing area} of $q$ follows: $\sensarea: Q \mapsto 2^{Q}$, such that  $\forall q^\prime \in \sensarea(q), \sensfunc(q) = \world_Q(q)$.  
\end{definition}




Let $\map_i:Q\mapsto \left\{-1,0\right\}$ denote a \qdfunc \emph{local} to robot $i$, which we can see as a software state for a given robot $i$ as well.  % $\map_i(q) = 1$ indicates that according to robot $i$, there is an obstacle in $q$, $\map_i(q) = 0$ indicates that according to robot $i$, $q$ is unoccupied, and $\map_i(q) = -1$ indicates that robot $i$ doesn't have information about $q$.



We assume that given $\Vec{x} \in q, \forall \Vec{x^\prime} \in q, \sensarea(\Vec{x}) \subseteq \sensarea(\Vec{x^\prime})$. We can now state the 2-d distributed mapping problem, $\mapprob$ as follows. \begin{quote}
{\em Given a set of robots $[N]$ , for each robot $i \in [N]$ construct an \emph{occupancy map}, $\map_i: Q_i \mapsto \left\{1,0\right\}$, $Q_i\subseteq Q$.
}
\end{quote}

% \rg{We can \emph{combine} the elements of the set of \emph{local maps}, $\{\map_i\}_{i\in [N]}$ to form a \emph{global} occupancy mapping. }

Having stated the problem, we now define the notion of soundness of a proposed occupancy map.
\begin{definition}
    \label{soundness}
   
\end{definition}


These two statements collectively state that given a proposed occupancy map, \emph{any grid rectangle in the domain of the occupancy map marked as 0 is indeed obstacle free, and if it is marked as 1 then there is indeed an obstacle at least partially in it.}

%We define $\mathit{Adj}_{q_{ij}}$ as the set $\{q_{i^\prime j^\prime}\mid i^\prime \in \{i, i+1,i-1\}\wedge j^\prime \in \{j,j+1,j-1\}\wedge q_{i^\prime j^\prime} \neq q_{ij}\}$


A vacuously correct (sound) solution to $\mapprob$ given $D, \qfunc$ and $\world_Q$ is $\forall i \in [N]$, $$\map_i : Q_i \mapsto \left\{0,1\right\}, Q_i = \phi$$ To allow for potentially more interesting solutions than the one stated above, we assume that we are given that initially, each robot $i\in[N]$ starts at a grid rectangle with no obstacle, the sensed area of each robot $i$ is non empty
$\forall i \in [N], \world_Q(q^0_i) = 0\wedge \sensarea(q^0_i) \neq \phi$
where $q^0_i = \qfunc(\pos_0(i))$, and $\pos_0(i)$ denotes the initial position of robot $i$.

%
%\begin{definition}
%    Given  $i , j \in [N]$, two proposed occupancy mappings $\map_i: Q_i\mapsto\left\{0,1\right\}$ and $\map_j: Q_j\mapsto \left\{0,1\right\}$, are consistent only if $\forall q \in Q_i \cup Q_j, \map_i(q) = \map_j(q)$.
%\end{definition}

    Given $\map_i$, $\map_j$, and $q\in Q_i \cup Q_j$ , let $\map_i(q) = 1$, and $\map_j(q) = 0$. Suppose $\map_i$ is sound, then $\world_Q(q) = 1$, which implies $\map_j$ is not sound. By the same argument, if $\map_j$ is sound, $\map_i$ is not. Each mapping in a set of proposed mappings $\left\{\map_i\right\}_{i\in [N]}$ can only be sound if they are pairwise consistent.

Given a mapping $\map_i$, $\mathit{dom}(\map_i)$ denotes $ Q_i \subset Q$, such that $\forall q \in Q_i \map_i(q) = 0 \vee \map_i(q) = 1$.
\begin{definition}
    \label{cons}
Consider a set of sound mappings $\left\{\map_i\right\}_{i\in[N]}$. The \emph{ combined mapping} described by $\map: Q^\prime \mapsto \left\{0,1\right\}$ where $Q^\prime = \bigcup_{i\in[N]} \mathit{dom}(\map_i)$ , and $\exists j \in [N], q\in \mathit{dom}(\map_j)\Rightarrow \map(q) = \map_j(q)$ is also sound.
\end{definition}

$\map$ is sound by construction, and consistency of the sound mappings it is constructed from.
