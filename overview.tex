\section{Overview and an example}
\label{sec:overview}

%\chiao{1\textasciitilde1.5 pages}
\newcommand{\LineForm}{\textsf{LineForm}\xspace}

We will discuss the key features of the \lgname language and programming system with an example.
The \lgname application shown in \reffig{lineform} is a simple formation control protocol of the type often used for drone shows like the one seen in \reffig{firefly}.
The code in \reffig{lineform} makes an arbitrary number of robots (drones) line up uniformly between two extremal robots.
Small modifications to the code make the drones form other shapes like squares, cubes, and stars.

\subsection{\lgname language}
\label{sec:koord-language}
% 1 sentence intro of the language
\lgname is a high-level, event-driven language in which application programs use \emph{shared variables} for coordination across robots
and \emph{ports} for interacting with hardware-specific subroutines.
In a distributed robotics setting, instances of the same \lgname program is executed by each participating robots to solve problems collectively.

\begin{figure}[h!]
    \two{0.32}{0.59}
    {
        \lstinputlisting[language=NumKoord, lastline=8]{code/lineform.tex}
    }
    {
        \lstinputlisting[language=NumKoord, firstline=9, firstnumber=9]{code/lineform.tex}
    }
    \caption{\lgname program \LineForm for a set of robots to form a line.}
    \label{fig:lineform}
\end{figure}

\paragraph{Module ports and local variables.}
A \lgname program interacts with the sensors and low-level controllers of the robot platform through \emph{sensor} and \emph{actuator} ports.
The program can read data from the sensor ports and can write data to actuator ports.
%
The \LineForm application uses a \emph{module} (library) called \emph{Motion} which provides a sensor port called \emph{position} that publishes the robot's position.
The \emph{Motion} module also provides a port called \emph{target} for specifying a target position.

A \lgname program can use multiple modules providing different sensor and actuator ports.
As shown in \reffig{arch}, the actuator ports of different modules can be used to provide input to the controllers,
which drives the underlying physical plant and environment.
The sensor ports are  updated according to the real world physics, as perceived by the controllers.
%
\marginpar{\scriptsize\sayan{1. actuator ports ``can be'' used or ``are used'' ? How else could they be used? 2. The term controller is confusing there and in Fig 1.}}
%
Thus, the module ports provide an abstraction over various possible controller implementations and environments.
For example, our implementation of the \emph{position} port for \emph{Motion} module uses an indoor camera based positioning system to track positions of drones.
Alternatively, users may use GPS to implement the \emph{Motion} module in an outdoor setting.
In short, different controllers in use would largely affect the behavior of each robot and its interaction with the environment.

In addition to sensors and actuators, \lgname also allows declaring \emph{local} variables similar to most programming languages.
Note that a \lgname is run on a system of robots;
therefore, each participating robot would have its own set of module ports and local variables from the system point of view.
%
\marginpar{\scriptsize\sayan{What does ``system point of view'' mean?}}
%
\paragraph{Shared variables and system parameters.}
\lgname provides \emph{shared} variables to allow participating robots to communicate with each other.
At Line~\ref{lineform-allread} in \reffig{lineform}, an \textbf{allread} variable, $x$, is a shared variable of array type which all robots can read from,
but each robot \myuin can only write to $x[\myuin]$.
This shared array is used to share the current position of each robot with all other robots.
\chiao{Should we discuss about atomic blocks and mutual exclusion here.}
\sayan{not in any detail. 1 sentence forward pointer.} 
% Sayan: Not in detail 

The robot also has access to system-level \emph{constant} parameters.
For \LineForm as an example, it uses
\begin{inparaenum}[(a)]
    \item the unique integer identifier \myuin for itself and
    \item the number \NMAX of all participating robots.
\end{inparaenum}
A detail list of system parameters will be discussed later in \refsect{language}.


\subsection{Formal Semantics and Invariant Checking}

\sayan{We have developed/implemented the full semantics of \lgname using \K~\cite{Kcite}. The details are presented in Section~\ref{}.}
This formalization not only enables us to formally define the execution semantics for \lgname applications, 
\marginpar{\scriptsize\sayan{Elaborate why this is challenging? CPS, shared memory, asynchrony?}}
but we can also implement different formal analyses using \sayan{search/rewriting/which system/artifact of} \K.
In this work, we demonstrate an approach that checks invariant for \lgname programs using the symbolic execution semantics in \K~\cite{}.

For \LineForm, a natural requirement is to restrict all the robots to stay within a certain safe area, at all times (Geofencing).
More precisely, given a (hyper)rectangle $rect(x_{min}, x_{max})$ defined by its two corners $x_{min}$ and $x_{max}$,
if all robots are initialized within the rectangle, then all robots should always stay in the rectangle. This requirement can be stated as:
%Formally, we would like to prove following invariant:
\begin{invariant}\label{inv:lineform}
\[
\begin{split}
    \forall \myuin \in \UINS,\ M.pos_{\myuin} \in rect(x_{min}, x_{max}) \\
    \land\ x[\myuin] \in rect(x_{min}, x_{max})
\end{split}
\]
\normalfont{where $M.pos$ is the shorthand for $Motion.position$ and $M.tgt$ for $Motion.target$.}
\end{invariant}

\chiao{Explain why we need assumptions over modules.}
\sayan{Drop the extra line after Invariant~1. Why bother with the shorthand M.pos? M.tgt does not even appear in the invariant.}
\sayan{Ok, you can state the invariant...then what? can it be proved automatically using K? We should say that then with the appropriate qualifiers, and give a forward pointer.}

Motion module should ensure the device is moving within the bounding rectangle between its position and target
within a period of time $\delta$.
That is, given a black-box function $f$ returning positions of the device in continuous time,
we can formally define the assumption over the \emph{Motion} module as follows.
\begin{assumption}\label{lineform-assume}
\[
\forall \tau \in [0, \delta], f(M.pos, M.tgt, \tau) \in rect(M.pos, M.tgt)
\]
\end{assumption}

With the assumption, we can prove \inv{inv:lineform} inductively.
The \K semantics of \lgname allows us to construct the symbolic post states of event \emph{TargetUpdate}.
\chiao{Give the formula representing the symbolic post or transition relation of \emph{TargetUpdate}}

\begin{figure}
\begin{tikzpicture}[
    every node/.style={draw},
]
    \node (sym) {\K Symbolic Execution};
    \node [below of=sym] (prover) {\lgname prover};
    \node [diamond, aspect=2, below of=prover] (z3) {z3};
    \node [below left=1cm and 1cm of z3] (proven) {Proven};
    \node [below right=1cm and 1cm of z3] (incon) {Inconclusive};

    \draw [->] (sym) edge (prover)
               (prover) edge (z3)
               (z3) edge node[draw=none, left] {UNSAT} (proven)
               (z3) edge node[draw=none, right] {SAT} (incon)
               ;
\end{tikzpicture}
\caption{\K semantics based invariant checking for \lgname.}
\end{figure}
\marginpar{\scriptsize\sayan{Shouldn't this flowchart also have inputs Koord application code/requirement? Also, too much white space.}}

\subsection{Simulation based Assumption Validation}

\asum{lineform-assume} seems reasonable and sufficiently weak at the first glance,
but it actually imposes a very strong constraint over the $Motion$ module and the environment.
Using the simulation engine, we can monitor the sensor and actuator values to evaluate how often the assumption is violated.
For \asum{lineform-assume}, we can identify and demonstrate two common scenarios
where it is invalidated.
\chiao{We can use simulator screenshot to show the violation.}

First, if a robot has to avoid obstacles,
then it may have to go around the obstacle and hence out of the bound.
Second, the assumption simply fails over certain types of devices.
For example, four wheel cars doing parallel parking may easily go out of the rectangle
because the cars need more space to make turns.

In short, users can use the simulator to early detect whether
the assumptions for correctness are too strong under specific scenarios,
and revise the assumptions iteratively.
For example, to run the line formation program on cars,
a different module including the orientation of cars as well as more relaxed assumptions are needed.

\subsection{Compilation and Deployment.}
In addition to the formal language, semantics, analysis, and simulation,
our complete tool chain also includes compilation and deployment to heterogeneous platforms including drones and race cars.
Once developers install our ROS~\cite{ros} based run-time libraries~(middleware) on a platform
and provides a device specific configuration denoting the mapping from \lgname module ports
to low level sensor and actuator ROS messages,
our module port based abstraction then allows the same \lgname program to run on this platform.
Detailed description of our tool chain is available in~\cite{ghosh2019cyphyhouse}.
