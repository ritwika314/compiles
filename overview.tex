\section{Motivating Example}
\label{sec:overview}

\chiao{1\textasciitilde1.5 pages}

\chiao{
Use the example to informally introduce \lgname syntax.
Bring out how the distributed memory, abstraction on time, and black-box modules help simplify the design.
Discuss verbally what are the assumptions over run-time environment for proving the given example correct.
challenges---sensing, perception, coordination, movement.
}

%


We first give an overview of a line formation algorithm that controls robots to be uniformly distributed along a line.
Then we showcase the features of our programming language \lgname that enables us to design a succinct application for this algorithm.
We also discuss at a high level, how to use \toolname to simulate and test this application for a multi-robot system under various deployment scenarios.


\subsection{Koord program for Line Formation Algorithm}

\begin{figure}[h!]
    \two{0.32}{0.59}
    {
        \lstinputlisting[language=NumKoord, lastline=5]{code/lineform.tex}
    }
    {
        \lstinputlisting[language=NumKoord, firstline=7, firstnumber=7]{code/lineform.tex}
    }
    \caption{Koord program for Line Formation}\label{fig:lineform}
\end{figure}

$\lgname$ provides \emph{shared} variables to allow robots within a system to communicate with each other.
At Line~\ref{lineform-allread} in \reffig{lineform}, an \emph{allread} variable, $x$, is a shared variable of array type which all robots can read from,
but each agent $pid$ can only write to $x[pid]$.
This shared array of $Position$s is then used to share the current position of each agent to all other agents.

%\begin{itemize}
%    \item Multiple sensors
%    \item Sampled sensing : sensed over time.
%    \item Coordination using shared variables.
%    \item Mutual exclusion.
%\end{itemize}
% language features - what main "issue" each feature addresses .



The program and the controller interact with each other through \emph{sensor} and \emph{actuator} ports.
A $\lgname$ program can have multiple \emph{modules} providing different sensor and actuator ports.
The program reads the sensor ports, reads and writes to program variables, and writes to actuator ports.
The actuator ports of different modules can be used to provide input to the controller, which drives the underlying physical plant.


The robot also has access to two system-level \emph{constant} parameters (a) a unique integer identifier $\myuin$ for itself and (b) a list $\UINS$ of identifiers of all participating robots.\footnote{Our current system implementation assumes that the set of possible participating robots is known, but this assumption can be relaxed on a per application basis.}


\subsection{Invariant Checking}

\begin{invariant}
Given a rectangle defined by the two corners $x_{min}$ and $x_{max}$,
and all agents were initialized within the rectangle. They should always stay in the rectangle.
\[
\forall i, x[i] \in rect(x_{min}, x_{max})
\]
\end{invariant}


\begin{assumption}
Motion module ensures the device is moving within the bounding rectangle between its position and target.
\[
Motion.pos_{cur} \in rect(Motion.pos_{old}, Motion.target_{old})
\]
\end{assumption}

Drones, turtle bots, and roombas satisfy this assumption.
Cars however do not guarantee this. Consider parallel parking.
So a different module including the orientation of cars as well as new assumptions are needed.
