\section{Motivating Example}
\label{sec:overview}

\chiao{1\textasciitilde1.5 pages}

\chiao{
Use the example to informally introduce \lgname syntax.
Bring out how the distributed memory, abstraction on time, and black-box modules help simplify the design.
Discuss verbally what are the assumptions over run-time environment for proving the given example correct.
challenges---sensing, perception, coordination, movement.
}

We first give an overview of a line formation algorithm that controls robots to be uniformly distributed along a line.
Then we showcase the features of our programming language \lgname that enables us to design a succinct application for this algorithm.
We also discuss at a high level, how to use \toolname to simulate and test this application for a multi-robot system under various deployment scenarios.


\subsection{Koord program for Line Formation Algorithm}

\begin{figure}[h!]
    \two{0.32}{0.59}
    {
        \lstinputlisting[language=NumKoord, lastline=8]{code/lineform.tex}
    }
    {
        \lstinputlisting[language=NumKoord, firstline=9, firstnumber=9]{code/lineform.tex}
    }
    \caption{Koord program for Line Formation.}\label{fig:lineform}
\end{figure}

\chiao{Emphasize that the same program is executed on a system of robots.}

$\lgname$ provides \emph{shared} variables to allow robots within a system to communicate with each other.
At Line~\ref{lineform-allread} in \reffig{lineform}, an \emph{allread} variable, $x$, is a shared variable of array type which all robots can read from,
but each agent $pid$ can only write to $x[pid]$.
This shared array is used to share the current position of each agent to all other agents.

%\begin{itemize}
%    \item Multiple sensors
%    \item Sampled sensing : sensed over time.
%    \item Coordination using shared variables.
%    \item Mutual exclusion.
%\end{itemize}
% language features - what main "issue" each feature addresses .


The program and the controller interact with each other through \emph{sensor} and \emph{actuator} ports.
A \lgname program can have multiple \emph{modules} providing different sensor and actuator ports.
The program reads the sensor ports, reads and writes to program variables, and writes to actuator ports.
The actuator ports of different modules can be used to provide input to the controller, which drives the underlying physical plant.
The controllers in use determine the dynamic behavior of each agent and its interaction with the environment.
\reffig{arch} shows how each controller has sensor ports and actuator ports which the agent programs use to interact with the controller and consequently, with the physical environment.
The agent program can read from the sensor ports read and write to the actuator ports during the program transition.
The sensor ports are updated during the environment transition according to the controller dynamics.
%
The robot also has access to two system-level \emph{constant} parameters
\begin{inparaenum}[(a)]
\item a unique integer identifier $\myuin$ for itself and
\item a list $\UINS$ of identifiers of all participating robots.\footnote{Our current system implementation assumes that the set of possible participating robots is known, but this assumption can be relaxed on a per application basis.}
\end{inparaenum}

\subsection{Invariant Checking}

$pos$ is shorthand for $Motion.position$. $tgt$ is shorthand for $Motion.target$.

\begin{invariant}\label{inv:lineform}
Given all agents initialized within a rectangle defined by the two corners $x_{min}$ and $x_{max}$,
all agents should always stay in the rectangle.
\[
\begin{split}
    pos \in rect(x_{min}, x_{max})        \\
    \land\ \forall i, x[i] \in rect(x_{min}, x_{max})
\end{split}
\]
\end{invariant}


\begin{assumption}\label{lineform-assume}
Motion module should ensure the device is moving within the bounding rectangle between its position and target
within a period of time $\delta$.
Given an unknown function $f$ returning positions of the device in continuous time,
formally we can define the assumption over $f$:
\[
\forall \tau \in [0, \delta], f(pos, tgt, \tau) \in rect(pos, tgt)
\]
Or in \lgname we provide the shorthand,
\[
pos' \in rect(pos, tgt)
\]
\end{assumption}

With the assumption, we can prove \inv{inv:lineform} inductively.
The \K semantics of \lgname allows us to construct the symbolic post states of event \emph{TargetUpdate}.


\begin{figure}
\begin{tikzpicture}[
    every node/.style={draw},
]
    \node (sym) {\K SymExec};
    \node [below of=sym] (prover) {\lgname prover};
    \node [diamond, aspect=2, below of=prover] (z3) {z3};
    \node [below left=1cm and 1cm of z3] (proven) {Proven};
    \node [below right=1cm and 1cm of z3] (incon) {Inconclusive};

    \draw [->] (sym) edge (prover)
               (prover) edge (z3)
               (z3) edge node[draw=none] {UNSAT} (proven)
               (z3) edge node[draw=none] {SAT} (incon)
               ;
\end{tikzpicture}
\end{figure}


\subsection{Simulation based Assumption Validation}

\asum{lineform-assume} seems reasonable and sufficiently weak at the first glance,
but it actually imposes a very strong constraint over the $Motion$ module and the environment.
Using the simulation engine, we can monitor the sensor and actuator values to evaluate how often the assumption is violated.
For \asum{lineform-assume}, we can identify and demonstrate two common scenarios
where it is invalidated.

\chiao{We can use simulator screenshot to show the violation.}

First, if a robot has to avoid obstacles,
then it may have to go around the obstacle and hence out of the bound.
Second, the assumption simply fails over certain types of devices.
For example, four wheel cars doing parallel parking may easily go out of the rectangle
because the cars need more space to make turns.

In short, users can use the simulator to early detect whether
the assumptions for correctness are too strong under specific scenarios,
and revise the assumptions iteratively.
For example, to run the line formation program on cars,
a different module including the orientation of cars as well as more relaxed assumptions are needed.
