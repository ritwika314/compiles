\section{Overview and an example}
\label{sec:overview}

%\chiao{1\textasciitilde1.5 pages}
%
%\chiao{
%Bring out how the distributed memory, abstraction on time, and black-box modules help simplify the design.
%challenges---sensing, perception, coordination, movement.
%}
\newcommand{\LineForm}{\textsf{LineForm}\xspace}

We will discuss the key features of the \lgname language and programming system with an example.
The \lgname application shown in \reffig{lineform} is a simple formation control protocol of the type often used for drone shows like the one seen in \reffig{firefly}.
The code in \reffig{lineform} makes an arbitrary number of robots (drones) line up uniformly between two extremal robots.
\sayan{Small modifications} to the code make the drones form other shapes like  squares, cubes, and stars.

\subsection{\lgname language}
\label{sec:koord-language}
% 1 sentence intro of the language
\lgname is a high-level, event-driven language in which application programs use \emph{shared variables} for coordination across robots and \emph{ports} for interacting with hardware-specific subroutines.

\begin{figure}[h!]
    \two{0.32}{0.59}
    {
        \lstinputlisting[language=NumKoord, lastline=8]{code/lineform.tex}
    }
    {
        \lstinputlisting[language=NumKoord, firstline=9, firstnumber=9]{code/lineform.tex}
    }
    \caption{\lgname program \LineForm for a set of agents to form a line.}
    \label{fig:lineform}
\end{figure}

\paragraph{Variables and ports.}
A \lgname program interacts with the sensors and low-level controllers of the robot platform through \emph{sensor} and \emph{actuator} ports.
The program can read data from the sensor ports and can write data to actuator ports, and in addition it can reads and writes to program variables.
%
The \LineForm application uses a module (library) called \emph{Motion} which provides a sensor that publishes the robot's location in a port called \emph{position}.
The motion module also a port called \emph{target} for \sayan{introduce sensor and actuator ports using the \LineForm example.}

A \lgname program can have multiple \emph{modules} providing different sensor and actuator ports.
The actuator ports of different modules can be used to provide input to the controller, which drives the underlying physical plant.
\sayan{sentence about middleware implementing the connection between ports and low-level hardware/controllers, with example.}
The controllers in use determine the dynamic behavior of each agent and its interaction with the environment.
\reffig{arch} shows how each controller has sensor ports and actuator ports which the agent programs use to interact with the controller and consequently, with the physical environment.
%The agent program can read from the sensor ports read and write to the actuator ports during the program transition.
The sensor ports are updated during the environment transition according to the controller dynamics.
%
The robot also has access to two system-level \emph{constant} parameters


\paragraph{Shared variables.}
\lgname provides \emph{shared} variables to allow robots within a system to communicate with each other.
At Line~\ref{lineform-allread} in \reffig{lineform}, an \emph{allread} variable, $x$, is a shared variable of array type which all robots can read from,
but each agent $pid$ can only write to $x[pid]$.
This shared array is used to share the current position of each agent to all other agents.

%\begin{itemize}
%    \item Multiple sensors
%    \item Sampled sensing : sensed over time.
%    \item Coordination using shared variables.
%    \item Mutual exclusion.
%\end{itemize}
% language features - what main "issue" each feature addresses .




\begin{inparaenum}[(a)]
\item a unique integer identifier $\myuin$ for itself and
\item a list $\UINS$ of identifiers of all participating robots.\footnote{Our current system implementation assumes that the set of possible participating robots is known, but this assumption can be relaxed on a per application basis.}
\end{inparaenum}

\chiao{Emphasize that the same program is executed on a system of robots.}


\paragraph{Modules and system configurations}
- Implementation of module interfaces
- e.g., implementation using ROS
- Configuration file (system parameters) pid, $N_{sys}$, $\delta$


\subsection{Invariant Checking}

$pos$ is shorthand for $Motion.position$. $tgt$ is shorthand for $Motion.target$.

\begin{invariant}\label{inv:lineform}
Given all agents initialized within a rectangle defined by the two corners $x_{min}$ and $x_{max}$,
all agents should always stay in the rectangle.
\[
\begin{split}
    pos \in rect(x_{min}, x_{max})        \\
    \land\ \forall i, x[i] \in rect(x_{min}, x_{max})
\end{split}
\]
\end{invariant}


\begin{assumption}\label{lineform-assume}
Motion module should ensure the device is moving within the bounding rectangle between its position and target
within a period of time $\delta$.
Given an unknown function $f$ returning positions of the device in continuous time,
formally we can define the assumption over $f$:
\[
\forall \tau \in [0, \delta], f(pos, tgt, \tau) \in rect(pos, tgt)
\]
Or in \lgname we provide the shorthand,
\[
pos' \in rect(pos, tgt)
\]
\end{assumption}

With the assumption, we can prove \inv{inv:lineform} inductively.
The \K semantics of \lgname allows us to construct the symbolic post states of event \emph{TargetUpdate}.


\begin{figure}
\begin{tikzpicture}[
    every node/.style={draw},
]
    \node (sym) {\K SymExec};
    \node [below of=sym] (prover) {\lgname prover};
    \node [diamond, aspect=2, below of=prover] (z3) {z3};
    \node [below left=1cm and 1cm of z3] (proven) {Proven};
    \node [below right=1cm and 1cm of z3] (incon) {Inconclusive};

    \draw [->] (sym) edge (prover)
               (prover) edge (z3)
               (z3) edge node[draw=none] {UNSAT} (proven)
               (z3) edge node[draw=none] {SAT} (incon)
               ;
\end{tikzpicture}
\end{figure}


\subsection{Simulation based Assumption Validation}

\asum{lineform-assume} seems reasonable and sufficiently weak at the first glance,
but it actually imposes a very strong constraint over the $Motion$ module and the environment.
Using the simulation engine, we can monitor the sensor and actuator values to evaluate how often the assumption is violated.
For \asum{lineform-assume}, we can identify and demonstrate two common scenarios
where it is invalidated.

\chiao{We can use simulator screenshot to show the violation.}

First, if a robot has to avoid obstacles,
then it may have to go around the obstacle and hence out of the bound.
Second, the assumption simply fails over certain types of devices.
For example, four wheel cars doing parallel parking may easily go out of the rectangle
because the cars need more space to make turns.

In short, users can use the simulator to early detect whether
the assumptions for correctness are too strong under specific scenarios,
and revise the assumptions iteratively.
For example, to run the line formation program on cars,
a different module including the orientation of cars as well as more relaxed assumptions are needed.

\subsection{Compiler / execution platform.}
One para about all the supporting tools (simulator, compiler, deployment tools) with pointers to figures.
- Cite ICRA, arxiv
- Heterogeneous platforms
- Forward pointer to Section 4/6 where these are discussed in more detail.
