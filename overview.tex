\section{Overview and an example}
\label{sec:overview}

%\chiao{1\textasciitilde1.5 pages}
%
%\chiao{
%Bring out how the distributed memory, abstraction on time, and black-box modules help simplify the design.
%challenges---sensing, perception, coordination, movement.
%}
\newcommand{\LineForm}{\textsf{LineForm}\xspace}

We will discuss the key features of the \lgname language and programming system with an example.
The \lgname application shown in \reffig{lineform} is a simple formation control protocol of the type often used for drone shows like the one seen in \reffig{firefly}.
The code in \reffig{lineform} makes an arbitrary number of robots (drones) line up uniformly between two extremal robots.
\sayan{Small modifications} to the code make the drones form other shapes like  squares, cubes, and stars.

\subsection{\lgname language}
\label{sec:koord-language}
% 1 sentence intro of the language
\lgname is a high-level, event-driven language in which application programs use \emph{shared variables} for coordination across robots
and \emph{ports} for interacting with hardware-specific subroutines.
In the distributed robotic control setting, the same \lgname program is executed on a system of robots to solve problems collectively.

\begin{figure}[h!]
    \two{0.32}{0.59}
    {
        \lstinputlisting[language=NumKoord, lastline=8]{code/lineform.tex}
    }
    {
        \lstinputlisting[language=NumKoord, firstline=9, firstnumber=9]{code/lineform.tex}
    }
    \caption{\lgname program \LineForm for a set of robots to form a line.}
    \label{fig:lineform}
\end{figure}

\paragraph{Module ports and local variables.}
A \lgname program interacts with the sensors and low-level controllers of the robot platform through \emph{sensor} and \emph{actuator} ports.
The program can read data from the sensor ports and can write data to actuator ports.
%
The \LineForm application uses a \emph{module} (library) called \emph{Motion} which provides a sensor port called \emph{position} that publishes the robot's position.
The motion module also a port called \emph{target} for specifying a target position.

A \lgname program can have multiple modules providing different sensor and actuator ports.
As shown in \reffig{arch}, the actuator ports of different modules can be used to provide input to the controllers,
which drives the underlying physical plant and environment.
The sensor ports are then updated according to the real world physics perceived by the controllers.
It is worth noting that module ports provide a significant abstraction over various possible controller implementations and environments.
For example, our implementation of the \emph{position} port for \emph{Motion} module uses an indoor camera based positioning system
to track positions of drones.
Users can also use GPS to implement the \emph{Motion} module in an outdoor setting.
The sampling frequencies of sensors are also abstracted away in \lgname as well.
In short, different controllers in use would largely affect the behavior of each robot and its interaction with the environment.

In addition to sensors and actuators, \lgname also allows declaring \emph{local} variables similar to most programming languages.
Note that a \lgname is run on a system of robots;
therefore, each participating robot would have its own set of module ports and local variables from the system view.


\paragraph{Shared variables and system parameters.}
\lgname provides \emph{shared} variables to allow robots within the system to communicate with each other.
At Line~\ref{lineform-allread} in \reffig{lineform}, an \emph{allread} variable, $x$, is a shared variable of array type which all robots can read from,
but each robot \myuin can only write to $x[\myuin]$.
This shared array is used to share the current position of each robot to all other robots.
\chiao{Should we discuss about atomic blocks and mutual exclusion here.}

The robot also has access to system-level \emph{constant} parameters.
For \LineForm as an example, it uses
\begin{inparaenum}[(a)]
    \item the unique integer identifier \myuin for itself and
    \item the number \NMAX of all participating robots.
\end{inparaenum}
A detail list of system parameters will be discussed later in \refsect{language}.


\subsection{Formal Semantics and Invariant Checking}

$pos$ is shorthand for $Motion.position$. $tgt$ is shorthand for $Motion.target$.

\begin{invariant}\label{inv:lineform}
Given all robots initialized within a rectangle defined by the two corners $x_{min}$ and $x_{max}$,
all robots should always stay in the rectangle.
\[
\begin{split}
    pos \in rect(x_{min}, x_{max})        \\
    \land\ \forall i, x[i] \in rect(x_{min}, x_{max})
\end{split}
\]
\end{invariant}


\begin{assumption}\label{lineform-assume}
Motion module should ensure the device is moving within the bounding rectangle between its position and target
within a period of time $\delta$.
Given an unknown function $f$ returning positions of the device in continuous time,
formally we can define the assumption over $f$:
\[
\forall \tau \in [0, \delta], f(pos, tgt, \tau) \in rect(pos, tgt)
\]
Or in \lgname we provide the shorthand,
\[
pos' \in rect(pos, tgt)
\]
\end{assumption}

With the assumption, we can prove \inv{inv:lineform} inductively.
The \K semantics of \lgname allows us to construct the symbolic post states of event \emph{TargetUpdate}.


\begin{figure}
\begin{tikzpicture}[
    every node/.style={draw},
]
    \node (sym) {\K SymExec};
    \node [below of=sym] (prover) {\lgname prover};
    \node [diamond, aspect=2, below of=prover] (z3) {z3};
    \node [below left=1cm and 1cm of z3] (proven) {Proven};
    \node [below right=1cm and 1cm of z3] (incon) {Inconclusive};

    \draw [->] (sym) edge (prover)
               (prover) edge (z3)
               (z3) edge node[draw=none] {UNSAT} (proven)
               (z3) edge node[draw=none] {SAT} (incon)
               ;
\end{tikzpicture}
\end{figure}


\subsection{Simulation based Assumption Validation}

\asum{lineform-assume} seems reasonable and sufficiently weak at the first glance,
but it actually imposes a very strong constraint over the $Motion$ module and the environment.
Using the simulation engine, we can monitor the sensor and actuator values to evaluate how often the assumption is violated.
For \asum{lineform-assume}, we can identify and demonstrate two common scenarios
where it is invalidated.

\chiao{We can use simulator screenshot to show the violation.}

First, if a robot has to avoid obstacles,
then it may have to go around the obstacle and hence out of the bound.
Second, the assumption simply fails over certain types of devices.
For example, four wheel cars doing parallel parking may easily go out of the rectangle
because the cars need more space to make turns.

In short, users can use the simulator to early detect whether
the assumptions for correctness are too strong under specific scenarios,
and revise the assumptions iteratively.
For example, to run the line formation program on cars,
a different module including the orientation of cars as well as more relaxed assumptions are needed.

\subsection{Compiler / execution platform.}
One para about all the supporting tools (simulator, compiler, deployment tools) with pointers to figures.
- Cite ICRA, arxiv
- Heterogeneous platforms
- Forward pointer to Section 4/6 where these are discussed in more detail.

\paragraph{Modules and system configurations}

- Implementation of module interfaces
- e.g., implementation using ROS
- Configuration file (system parameters) \myuin, \NMAX, $\delta$
