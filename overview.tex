\section{Overview and an example}
\label{sec:overview}

%\chiao{1\textasciitilde1.5 pages}
\newcommand{\LineForm}{\textsf{LineForm}\xspace}

We will discuss the key features of the \lgname language and programming system with an example.
The \lgname application \LineForm shown in \reffig{lineform} implements a simple formation control protocol of the type  used for drone shows like the one seen in \reffig{firefly}.
\LineForm makes an arbitrary number of robots (drones) line up uniformly between two extremal robots.
Small modifications to the code make the drones form other shapes like squares, cubes, and stars.

\subsection{\lgname language}
\label{sec:koord-language}
% 1 sentence intro of the language
\lgname is a high-level, event-driven language in which application programs use \emph{shared variables} for coordination across robots
and \emph{ports} for interacting with hardware-specific subroutines.
In a distributed robotics setting, instances of the same \lgname program is executed by each participating robots to solve problems collectively.

\begin{figure}[h!]
    \two{0.32}{0.59}
    {
        \lstinputlisting[language=NumKoord, lastline=8]{code/lineform.tex}
    }
    {
        \lstinputlisting[language=NumKoord, firstline=9, firstnumber=9]{code/lineform.tex}
    }
    \caption{\lgname program \LineForm for a set of robots to form a line.}
    \label{fig:lineform}
\end{figure}

\paragraph{Modules and port abstractions.}
A \lgname program interacts with the sensors and low-level controllers of the robot platform through \emph{sensor} and \emph{actuator} ports.
%
%
The program can read data from the sensor ports and can write data to actuator ports.
%
For example, \LineForm uses a \emph{module} (library) called \emph{Motion} which provides a sensor port called \emph{position} that publishes the robot's position, and an actuator port called \emph{target} for specifying a target position.
%
%A \lgname program can use several modules providing different sensor and actuator ports.
Thus, these  ports provide an abstraction over various possible sensor and controller implementations and environments.
%
\sayan{Implementations of the modules are part of the {\em Koord runtime system\/} and they implement hardware specific functions.}
%, the actuator ports of different modules can be used to provide input to the controllers,
%which drives the underlying physical plant and environment.

\sayan{For example, our implementation of the  \emph{Motion} module for a quadcopter uses an indoor camera based positioning system to update the \emph{position} port and it uses an RRT based~\cite{} path planner and motion controller.
%
The  \emph{Motion} module abstraction is implemented for a small racing vehicle platform using the same indoor positioning system but a different model-predictive controller.
}
%\sayan{Similarly, an implementation \emph{target}}

%
%For example the \emph{position} sensor port in \LineForm is periodically updated by the implemented \emph{Motion} module with the current position of the robot using  GPS or an indoor positioning system.
%
%\marginpar{\scriptsize\sayan{1. actuator ports ``can be'' used or ``are used'' ? How else could they be used? 2. The term controller is confusing there and in Fig 1.}}
%
%In short, different controllers in use would largely affect the behavior of each robot and its interaction with the environment.

\paragraph{Local and shared variables.}
 \lgname programs can have  \emph{local} variables similar to most programming languages.
%
%\marginpar{\scriptsize\sayan{What does ``system point of view'' mean?}}
%
%\paragraph{Shared variables and system parameters.}
In addition, they can also use \emph{shared} variables for participating robots to communicate with each other.
At Line~\ref{lineform-allread} in \reffig{lineform}, an \textbf{allread} variable, $x$, is a shared array which all robots can read from,  but each robot \myuin can only write to $x[\myuin]$.  This shared array is used to share the current position of each robot with all other robots. 
%There are several system-level \emph{constant} parameters that the program can use.
\LineForm uses
\begin{inparaenum}[(a)]
    \item the unique integer identifier \myuin for itself and
    \item the number \NMAX of all participating robots.
\end{inparaenum}
A detailed list of system parameters will be discussed later in \refsect{language}.


\sayan{$\lgname$ provides concurrency control with mutual exclusion and \textbf{atomic} blocks, for multiple robot programs writing to shared variables (see  {\sf Task} and {\sf Mapping} applications  in Section~\ref{}).}
%\chiao{Should we discuss about atomic blocks and mutual exclusion here.}
%\sayan{not in any detail. 1 sentence forward pointer.}
% Sayan: Not in detail 



%As a \lgname program is run on a system of robots,
%therefore, each participating robot would have its own set of module ports and local variables, along with a local copy of each  shared variable.
\marginpar{\scriptsize\sayan{Better move this in 4.}}

\subsection{Semantics and invariant properties}

We have developed the full semantics of \lgname using \K~\cite{rosu-serbanuta-2013-k}, and present the details in \refsect{sec:language}. The execution semantics of any applications for multi-robot system are complicated by issues of asynchrony, consistency of shared memory, and interactions between software and  the physical environment.
The \K rewriting engine makes the formal language semantics \emph{executable}, and enables exhaustive exploration of non-deterministic behaviors of \lgname applications.
In Section~\ref{}, we present a method for checking invariant properties for \lgname applications using symbolic execution of the $\lgname$ semantics in \K.

For \LineForm, a natural requirement is to restrict all the robots to stay within a certain safe area, at all times (Geofencing).
More precisely, given a (hyper)rectangle $\mathit{rect}(x_{min}, x_{max})$ defined by its two corners $x_{min}$ and $x_{max}$,
if all robots are initialized within the rectangle, then all robots should always stay in the rectangle. This requirement can be stated as:
%Formally, we would like to prove following invariant:
\begin{invariant}
\label{inv:lineform}
%$ \forall \myuin \in \UINS,\ M.pos_{\myuin} \in rect(x_{min}, x_{max}) \\$
%$ \ \ \ \ \  \land\ x[\myuin] \in rect(x_{min}, x_{max}),$\\
%
\[
\begin{split}
    \forall \myuin \in \UINS,\ M.pos_{\myuin} \in rect(x_{min}, x_{max}) \\
    \land\ x[\myuin] \in rect(x_{min}, x_{max})
\end{split}
\]
\normalfont{where $M.pos$ is the shorthand for $Motion.position$.}
\end{invariant}

\sayan{Using \lgname's supporting proof tools,   an invariant like the above can be established in two steps: first, assuming that all the robot positions are in $\mathit{rect}(x_{min}, x_{max})$, we show that the targets computed by  \LineForm are also in $\mathit{rect}(x_{min}, x_{max})$. 
The \K semantics of \lgname allows us to construct the symbolic post states of the  \emph{TargetUpdate} event and we can  automatically prove this using the $\lgname$ prover (\reffig{fig:tools}) as detailed in \refsect{verification}.
}

\sayan{The second step is to show,  that for any robot, assuming that the computed target are in $\mathit{rect}(x_{min}, x_{max})$, the controller implementing \emph{Motion} module indeed keeps the robot inside $\mathit{rect}(x_{min}, x_{max})$. 
} 
For this step, one has to reason about how each robot hardware moves when its implementation of the Motion module is given a target. In order to complete the proof of Invariant~\ref{inv:lineform}, we can state this as the following assumption with 
\begin{assumption}
\label{lineform-assume}
\[
\forall t \in [0, \delta], f(M.pos, M.tgt, t) \in rect(M.pos, M.tgt)
\]
\end{assumption}
\normalfont {where $M.tgt$ is the shorthand for $Motion.target$, 
$f$ is a function giving the position of the robot at time $t$, moving to $M.tgt$, from $M.pos$.}.
This assumption states that the robot's motion module should ensure that it is moving within the bounding rectangle between its position and target within the duration of a round.
%
%Given a black-box function $f$ returning positions of the device in continuous time,
%
In Section~\ref{}, we will discuss how these types of assumptions about the control system can be discharged using verification engines for reasoning about continuous behavior of dynamical systems.

%\chiao{Explain why we need assumptions over modules.}
%\sayan{Drop the extra line after Invariant~1. Why bother with the shorthand M.pos? M.tgt does not even appear in the invariant.}
%\sayan{Ok, you can state the invariant...then what? can it be proved automatically using K? We should say that then with the appropriate qualifiers, and give a forward pointer.}

%\chiao{Give the formula representing the symbolic post or transition relation of \emph{TargetUpdate}}
%\rg{Shouldnt we postpone this to the actual section?}
\begin{figure}
\begin{tikzpicture}[
    every node/.style={draw},
]
    \node (sym) {\K Symbolic Execution};
    \node [below of=sym] (prover) {\lgname prover};
    \node [diamond, aspect=2, below of=prover] (z3) {z3};
    \node [below left=1cm and 1cm of z3] (proven) {Proven};
    \node [below right=1cm and 1cm of z3] (incon) {Inconclusive};

    \draw [->] (sym) edge (prover)
               (prover) edge (z3)
               (z3) edge node[draw=none, left] {UNSAT} (proven)
               (z3) edge node[draw=none, right] {SAT} (incon)
               ;
\end{tikzpicture}
\caption{\K semantics based invariant checking for \lgname.}
\label{fig:tools}
\end{figure}
\marginpar{\scriptsize\sayan{Shouldn't this flowchart also have inputs Koord application code/requirement? Also, too much white space.}}

\subsection{Simulation based assumption validation}

\asum{lineform-assume} seems reasonable and sufficiently weak at the first glance,
but it actually imposes a very strong constraint over the $Motion$ module and the environment.
Using the simulation engine, we can monitor the sensor and actuator values to evaluate how often the assumption is violated.
For \asum{lineform-assume}, we can identify and demonstrate two common scenarios
where it is invalidated.
\chiao{We can use simulator screenshot to show the violation.}

First, if a robot has to avoid obstacles,
then it may have to go around the obstacle and hence out of the bound.
Second, the assumption simply fails over certain types of devices.
For example, four wheel cars doing parallel parking may easily go out of the rectangle
because the cars need more space to make turns.

In short, users can use the simulator to early detect whether
the assumptions for correctness are too strong under specific scenarios,
and revise the assumptions iteratively.
For example, to run the line formation program on cars,
a different module including the orientation of cars as well as more relaxed assumptions are needed.

\subsection{Compilation and Deployment.}
In addition to the formal language, semantics, analysis, and simulation,
our complete tool chain also includes compilation and deployment to heterogeneous platforms including drones and race cars.
Once developers install our ROS~\cite{ros} based run-time libraries~(middleware) on a platform
and provides a device specific configuration denoting the mapping from \lgname module ports
to low level sensor and actuator ROS messages,
our module port based abstraction then allows the same \lgname program to run on this platform.
Detailed description of our tool chain is available in~\cite{ghosh2019cyphyhouse}.
