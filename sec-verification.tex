\section{Formal analysis of $\lgname$ programs}
\label{sec:verification}
%\rg{round, program transition, event execution, $\delta$-transition are all defined at this point: program transition : events executed in some order, $\delta$-transition: simulataneous advancement of time, round = program + $\delta$-transition. }
% connect to definition of e.
%make the post definition on a set.
The semantics of $\lgname$ has been constructed to enable decoupled analyses of discrete and dynamic components of distributed multi-robot systems. As discussed in the previous sections, the \emph{events} in an $\lgname$ program comprise the discrete computations in the system. The effect of an agent $i$ executing event $e\in \Event$ on a configuration $c\in \pwg$, can be seen as a $\stmtrule$ application to  $\left\langle c.S, c.L, B \right\rangle $, where $B$ is the effect of $e$.

\subsection{Reachable Configurations}

 Given a set of system configurations $C$, we define the following:
 \begin{inparaenum}[(i)]
     \item $\Post(C,i,e)$ is the set of configurations which can be reached by robot $i$ executing event $e \in \Event$ from a configuration in $C$.
     \item$\Post(C,i)$ is the set of configurations which can be reached by robot $i$ executing an event from a configuration in $C$.
     \item$\Post(C,p)$ is the set of configurations reached during a program transition, when robots execute their events in the order $p$, where $p$ is a sequence of robot $\mathit{pids}$.
     \item $\Post(C)$ is the union of $\Post(C,p)$ over all orders $p$.
     \item$\Final(C)$ is the set of configurations reached from $C$ \emph{after} a program transition.
 \end{inparaenum}
\vspace{1mm}
\begin{mdframed}
\footnotesize
\begin{align*}
    \Post (C,i,e) &= \{ c^\prime\mid \ \ \exists c \in C, \left\langle c.S, c.L, B \right\rangle \stmtrule \left\langle c^\prime.S, c^\prime.L, \cdot \right\rangle \},\\ &\mbox{ where B is the effect of }e.\\
\Post(C,i) :=& \bigcup_e \Post(C,i,e),\\
\Post(C,p) := & \ \Post(\Post(C,\pinit), \prest)\\ & \cup \Post(C,\pinit)\\
\Post(C) :=& \bigcup_{p\in \mathit{perms}(\UINS)} \Post(C,p), \\
\Final(C) :=& \left\{ c\in \Post(C)\mid \forall i \in \UINS, c.L_i.\turn = \env \right\}.
\end{align*}
\end{mdframed}

Given a sequence (permutation) $p$, $\pinit$ refers to the first element (robot $\myuin$) of the permutation and $\prest$ refers to the rest of sequence. Also, $\mathit{perms}(\UINS)$ refers to the set of permutations of $\UINS$.
\fTBD{\rg{$\pinit, \prest$ are macros.}}
We define a function $\traj: \pwg \times \left[0,\delta\right]$, which represents the \emph{trajectory} of the system, or the intermediate values of the sensor ports during a $\delta$-transition. Given $c\in \pwg, t\in \left[0,\delta\right]$, $\traj(c,t)$ represents the configuration at time $t$. $\pt{t_1}{t_2}(C)$ is the set of configurations reached by the system over the interval $[t_1,t_2]$.
$$\pt{t_1}{t_2}(C) := \left\{c^\prime \mid \exists c\in C, t_1 \leq t\leq t_2 , c^\prime = \traj(c,t)\right\}$$

The set of points reached by an $\delta$-transition at $\delta$ time from $C$ is represented as $\ft{\delta}(C) := \pt{\delta}{\delta}(C)$. A \emph{frontier} set of configurations represents the set of configurations that can be reached from an initial configuration $C$ after \emph{completing} rounds of execution. We define $\frontier(C,0) := C$ and,
$$\frontier(C,n) := \ft{\delta}(\Final(\frontier(C,n-1))).$$

Finally, given a set of configurations $C_0\subset\pwg$, the set of states reachable in $n$ rounds can be defined inductively as $\Reach(C_0,0) := C_0$ and,
\begin{align*}
\Reach(C_0,n) := \Reach(C_0 &,n-1) \cup \Post(\frontier(C_0,n-1) \\ &\cup \pt{0}{\delta}(\Post(\frontier(C_0,n-1)))
\end{align*}



\subsection{Inductive Invariants}
An invariant of a system is a property that holds true for all reachable configurations of a system. Invariants can be used to specify, for instance, a safety property of a system such as no two robots are ever within a specified radius of each other. \rg{The types of invariants allowed by our prover module are shown in appendix...}.
%define invariants, pointer to syntax
Given a configuration $c \in \pwg$, let $\eec{\mathit{inv}}{c}$ represent an \emph{evaluation} i.e. the substitution of variables in $\mathit{inv}$ with their values from $c$.
%fix notation of evalution
 %Formally, we say that $\beta$ is an inductive invariant if given a set of initial configurations of a system $C_0 \in \pwg$, and an arbitrary configuration $c \in \pwg$,  $$\forall c_0 \in C_0, \eec{\mathit{inv}}{c_0} \wedge c(\beta) \Rightarrow \forall c^\prime \in \Reach(c,1), c^\prime(\beta).$$ In other words, if a property holds true in the initial states of a system, and it can be proved to hold for all configurations reachable in one round from any configuration it is known to hold in, then it is an invariant of the system.

\begin{definition}
\label{def:ii}
A property $\mathit{inv}$ is an \emph{inductive invariant} of a system if given a set of initial configurations of the system $C_0$, and an arbitrary configuration $c\in \pwg$, it satisfies the following :
$\bigwedge_{c_0\in C_0} \eec{\mathit{inv}}{c_0}\mbox{\textit{ (initial condition)}}$ and
$$\eec{\mathit{inv}}{c} \Rightarrow \forall c' \in \Reach(\left\{c\right\},1), \eec{\mathit{inv}}{c'} \mbox{\textit{ (induction hypothesis)}}.$$
\end{definition}
This definition states that property that is satisfied by the initial configuration(s) of a system, and also by any configuration reached during one round of execution from any configuration satisfying the property, is an invariant of the system.



\rg{In the latter part of this section we present three case studies to illustrate some of the formal analysis enabled by our prover module}.

Our proposed proof strategy for the presented case studies is a \emph{decoupling} of the environment and program transition behaviors, and separate analysis. Formal analysis of the dynamic behavior of the system during environment transitions is a difficult problem by itself. We express the constraints on the configurations reached during environment transitions as assumptions. The induction hypothesis can be restated as \begin{align*}\eec{\mathit{inv}}{c} \Rightarrow &(\forall c' \in \Post(\left\{c\right\}), \eec{\mathit{inv}}{c'} \wedge \\ &\forall c'' \in \pt{0}{\delta},(\Final(\incurly{c})) \eec{\mathit{inv}}{c''})\end{align*} We state $\eec{\mathit{inv}}{c} \Rightarrow \forall c'' \in \pt{0}{\delta}(\Final(\incurly{c})) $ as an assumption $A$, which can be verified separately by other tools, and tested using the CyPhyhouse simulator.

 A major source of nondeterminism in the behavior of these distributed programs with shared variables can be the order of writes to shared variables in one round, however, this is not a factor in proving inductive invariants.

\begin{lemma}
   \label{noninter}
Given an arbitrary (symbolic) configuration $c$ and an inductive invariant $\mathit{inv}$,
   {\small
   $$\bigwedge_{i\in \UINS}\bigwedge_{e \in \Event}  \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e)} \Leftrightarrow \forall c'' \in \Post(\left\{c\right\}), \eec{\mathit{inv}}{c}$$ }
\end{lemma}
\begin{proof}
Suppose that given an arbitrary configuration $c$, such that $\bigwedge_{i\in \UINS}\bigwedge_{e \in \Event} \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e)}$ holds true. Consider a permutation $\incurly{i_1,i_2,\ldots,i_{\NMAX}}$ of agents executing events $\incurly{e_1, e_2, \ldots , e_{\NMAX}}$ respectively in a program transition during a round, reaching configurations $c_1, c_2, \ldots, c_{\NMAX}$ respectively. By assumption, since $\Post(\incurly{c},i,e) = c_1$, $\eec{\mathit{inv}}{c_1}$. Since our assumption was about any arbitrary (symbolic) configuration $c$, the same argument therefore can be extended to all the configurations reached by the system during this program transition, i.e. $\forall c' \in \incurly{c_1, c_2, \ldots, c_n}, \eec{\mathit{inv}}{c}$.
\end{proof}

Given an event $e\in \Event$, we represent the precondition of an event as $\pre(e)$. The semantics ensures an event will not occur if the precondition is not satisfied. This and \lem{noninter} allows us to sharpen the induction hypothesis further :
    $$ \bigwedge_{i\in \UINS} \bigwedge_{e \in \Event}  (\eec{\mathit{inv}}{c} \wedge \pre(e) \wedge A \Rightarrow \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e) }).$$


The remainder of this section demonstrates the verification of proposed invariants on three case studies.

 %\rg{Detailed analysis of conditional statements within events?}.

\subsubsection*{Case Study: Lineform}
 We use the executable $\lgname$ semantics to prove \inv{lineform} inductively, as discussed in \refsect{overview}. For the \emph{Lineform} application, it has only one event \emph{TargetUpdate}. Let the precondition of this event be denoted by $\mathit{Pr}:= \neg (\myuin = \NMAX - 1 \vee \myuin = 0)$ holds. The premise of the induction hypothesis is unsatisfiable with the the precondition of this effect for the robots $0$ and $\NMAX-1$, meaning this invariant is vacuously validated for these robots.

Symbolically executing the effect of the event (for robot $i$) using \K semantics gives us the constraint $$E := \mathit{M.pos_i}' = (x[i-1] + x[i+1])/2  \wedge x[i]' = \mathit{M.pos}_i,$$ where the primed copies of the variables indicate their values after the event has executed. We omitted the details of the $+$ operation, as it is overloaded to extend to vectors.

The assumption we make to prove the inductive invariant, following directly from \asum{lineform-assume} in \refsect{overview} is $$A := \mathit{M.pos}_i' \in \mathit{rect}[\mathit{M.pos}_i,\mathit{M.tgt}_i] .$$
Again, the operators $\leq$ and $\geq$ indicate a component-wise re, The invariant for the current configuration is $$I: \mathit{M.pos}_i \in \mathit{rect}[x_{min}, x_{max}] \wedge x[i] \in \mathit{rect}[x_{min}, x_{max}]$$ and  the invariant in the post event configuration is $$I' := \mathit{M.pos}_i' \in \mathit{rect}[x_{min}, x_{max}] \wedge x'[i] \in \mathit{rect}[x_{min}, x_{max}].$$
The overall induction hypothesis then becomes $$ \bigwedge_{i\in \UINS}\mathit{Pr} \wedge E \wedge A \wedge  I \Rightarrow I'$$.
Table \ref{tab:lineform} summarizes the verification of this constraints on systems of different sizes.
\begin{table}
    \label{tab:lineform}
    \scriptsize
 \centering
   \begin{tabular}{ l|  c c c c  }
 \hline
 \tb{Benchmark}       & \tb{robots}(N) & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 Lineform       & 3     &4.90  &9.09   & \Checkmark  \\
Lineform       & 4      &4.79  &12.21  & \Checkmark   \\
 Lineform       & 5      &4.91  &18.46  & \Checkmark   \\
Lineform        & 10     &10.92   &32.34   & \Checkmark  \\
Lineform         & 15    &12.23  & 53.89   &\Checkmark

\end{tabular}
    \caption{ \small Summary of semantics based verification for \emph{Lineform}.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the verification time in Z3 and \emph{robots}(N) is the number of robots in the system.}
\end{table}


% \begin{table}[!t]
%\scriptsize
% \centering
%  \caption{\small Summary of semantics based verification.  The \emph{robots}(N) is the number of robots in the system, $T_R$ is the total verification time in seconds (K + Z3).}
%  \label{tab:verif}
%   %\begin{tabular}{|l|l|l|l|l|l|l|l|c|}
%   \begin{tabular}{ l|  c c  c  }
% \hline
% \tb{Benchmark}       & \tb{robots}(N) & $T_R$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
% Lineform       & 3       &9.09   & \Checkmark  \\
%Lineform       & 4      & 11.21  & \Checkmark   \\
% Lineform       & 5        &  12.41  & \Checkmark   \\
%  Task       & 3       &14.12   & \Checkmark  \\
%Task       & 4      & 18.28  & \Checkmark   \\
% Task       & 5        &  19.61  & \Checkmark   \\
% \hline
% \end{tabular}
% \end{table}

%The effect of the event (for robot $i$) is $E := mt_i' = (x_{i-1} + x_{i+1})/2  \wedge x_i' = mp_i$.  The assumption (as stated earlier) is $A := mp_i' \leq mt_i \wedge mp_i' \geq mp_i)$. \rg{Additionally, we need a constraint $F:= x_{i-1} \in [x_{min}, x_{max}] \wedge x_{i+1}\in [x_{min},x_{max}]$.} The invariant is $I: \mathit{mp}_i \in [x_{min}, x_{max}]$ and $I'$ denotes the invariant $\mathit{mp}_i' \in [x_{min}, x_{max}]$.  The overall constraint then becomes :
                   %$E \wedge A \wedge F \wedge I \Rightarrow I'$, which we verified for models of size 3,4 and 5 using \K and Z3.

\newcommand{\Task}{\textsf{Task}\xspace}

\subsubsection*{Case Study: \Task}
The problem statement for the \Task application is as follows: {\small \em \Task: Given a set of (possibly heterogeneous) robots, a safety distance $d_s>0$, and a sequence of points (tasks) $\mathit{list} = x_1, x_2, \ldots \in \reals^3$, it is required that: (a) every unvisited $x_i$ in the sequence is {\em visited\/} exactly by one robot; and (b) no two robots ever get closer than $d_s$.\/}

The $\lgname$ program used to solve this problem in this paper implements a fairly straightforward solution\footnote{\rg{Presented in full in appendix/supplementary material or include here?}}. Robot $i$ looks for an unassigned task $x$ from $\mathit{list}$; if there is a clear path to $x$ then $i$ assigns itself the task $x$. It shares its path with all other robots, and  visits $x$ following the path; once done it repeats the process.  We aim to prove the \emph{safety} of this application with respect to collisions among agents, i.e. \emph{no two robots ever get closer than $d_s$}.



This application has two events \begin{inparaenum} \item {Assign}, in which each agent tries to assign itself to an unassigned task with a clear path  and \item \emph{Complete}, which checks whether an agent has visited its assigned task. \end{inparaenum} The robots use a shared allread variable $\pathvar$ to communicate the current path they are following to get to a task location, or their current position if they are stationary. A path here is a list of points that the robot visits in sequence. The \Motion module drives the robot along a path, as directed by the position value set at its actuator port $\mathit{Motion.path}$. The sensor port $\mathit{Motion.planner}$ returns a path to the target of an unassigned task, and a (user-defined) function called $\mathit{pathIsClear}$ is used to determine whether the currently planned path is within $d_s$ distance of any of paths (or positions) in $\pathvar$.

Suppose there is a function $f : [Point] \times [Point] \mapsto \mathbb{B}$ such that $f(x, y)$ is \emph{True} if $x$ and $y$ are at least $d_s$ distance apart, where $x$ and $y$ are either paths or positions. The invariant we want to prove is the following:

\begin{invariant}
\label{inv:task}
\[
    \forall i,j, \in \UINS, f(M.pos_i, M.pos_j)
\]
\end{invariant}
\noindent


Computing the $\mathit{pathIsClear}$ function,involves two nested loops over the length of each path, computing the minimum distance between each path segment. Proving invariants over these loops is by itself a difficult problem, so our symbolic execution treats any user-defined functions as uninterpreted functions. We require assumptions on the output of these functions. For any agent $i$ trying to assign itself to a task, we  assume the following :

\begin{assumption}
    \label{pathclear}
    $\mathit{pathIsClear}(\mathit{sp}, \mathit{cp} ,i, \mathit{ds})$ returns true only if the shared paths the proposed path $\mathit{cp}$ never comes within $d_s$ distance of any of the shared paths (or positions) $\mathit{sp}$. $$\forall j \in \UINS, pathIsClear(sp, cp,  i, d_s) \wedge j \neq i \Rightarrow  f(sp[j], cp)$$
\end{assumption}
 The index $i$ in the $\mathit{pathIsClear}$ function indicates that the previously shared path or position of the agent $i$ shouldn't be considered in the computation.

The second assumption we make is that an agent moves closely along its $\mathit{Motion.path}$ actuator whose value is denoted by $\mathit{M.path}$ until it finishes traversing the path.  We also denote $\mathit{Motion.reached}$ by $\mathit{M.reached}$.
\begin{assumption}
        \label{stlinemotion}
 There is an $\epsilon << d_s$, such that given a function $f' : [Point] \times [Point] \mapsto \mathbb{B}$  where $f'(x, y)$ is \emph{True} if $x$ and $y$ are at \emph{most} $\epsilon$ distance apart, where $x$ and $y$ are either paths or positions,
    $$\neg M.reached_i \Rightarrow f'(M.pos_i, sp[i])$$
\end{assumption}

 From \asum{pathclear} and \asum{stlinemotion}, to prove \inv{inv:lineform}, we only need to prove the following invariant.

\begin{invariant}
\label{inv:paths}
\[
    \forall i,j, \in \UINS,\  f(\pathvar[i], \pathvar[j])
\]
\end{invariant}
\noindent

Table \ref{tab:task} summarizes the verification of this constraints on systems of different sizes.
\begin{table}
    \label{tab:task}
    \scriptsize
 \centering
   \begin{tabular}{ l|  c c c c  }
 \hline
 \tb{Benchmark}       & \tb{robots}(N) & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 Task       & 3     &9.90  &10.6   & \Checkmark  \\
Task       & 4      &9.79  &11.78  & \Checkmark   \\
 Task       & 5      &9.91  &14.92  & \Checkmark   \\
Task        & 10     &12.92   &18.34   & \Checkmark  \\
\end{tabular}
    \caption{ \small Summary of semantics based verification for \Task.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the verification time in Z3 and \emph{robots}(N) is the number of robots in the system.}
\end{table}




\subsubsection*{Case Study: Mapping}

 The problem requires a set of robots to collaboratively mark the position of static \emph{obstacles} within a given area $D$ quantized by a \emph{grid}, which any robot should avoid while moving in $D$.The key difference between distributed SLAM and this application is that we assume that the robots know their \emph{global coordinates} within the area of deployment. They are only attempting to map the static obstacles within this area. We assume that the only sensors available for sensing obstacles are LIDAR based, and the robots are constrained to move in a 2-D space.


 Our approach requires each robot to construct a \emph{local mapping} of the grid over $D$ using sensors, and update it using information from other robots shared via a \emph{global mapping}. \footnote{A formalization of this problem is provided in full in the supplementary materials. }

\newcommand{\MotionWithScan}{\emph{MotionWithScan}\xspace}

In $\dmap$, the \MotionWithScan module provides a $\mathit{pscan}$ sensor used to read the LIDAR scan of the actual robot. The other sensors and actuators $\mathit{position,reached,planner,path}$ have the same functionality as that in the \Motion module.

 The $\lgname$ program corresponding to this solution has three \emph{events}: \emph{NewPoint, LUpdate, GUpdate}. The shared allwrite variable $\gmap$ is used to construct a shared map of obstacles within the domain $D$, and has type $\mathit{GridMap}$, which is a 2-D array representing a grid over $D$. The local variable $\lmap$ represents each robot's \emph{local} knowledge of the domain $D$, and has the same type as $D$. A robot executing the \emph{NewPoint} event, finds an unoccupied point to move to using a user defined function $\mathit{pickFrontierPos}$ and plans a path to it using $\mathit{MotionWithScan.planner}$. It then updates its $\lmap$ from the shared variable $\gmap$. The $\mathit{LUpdate}$ event updates the $\lmap$ with scanned sensor data while the robot is in motion, and the $\mathit{GUpdate}$ event updates the shared $\gmap$ with the updated $\lmap$ information corresponding to the scanned data.




