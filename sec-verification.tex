\section{verification}
\label{sec:verification}
\rg{statement about automated parts and manual parts of a correctness proof}. Using our \K prover module, we prove the inductive invariant, for a \emph{specific number of agents}, \rg{and later generalize the proof for an arbitrary number of agents manually}. The user specifies the desired inductive invariant along with any additional assumptions, which may include assumptions on properties the vehicle dynamics, or any functions used in the code. The prover module first generates the constraints on the variables determined by the effects of each event separately. We use bookkeeping to collect the constraints generated by the property specification along with the context to evaluate them as part of the configuration in \K. Let $\mathit{Eval} : P \times M  \mapsto \mathbb{B} $, be an \emph{evaluation} mapping a predicate and its evaluation context to true or false,  where $P$ is  the set of predicates defined on the variables and ports of a program, and $M$ is the possible set of valuations of these variables. Suppose the precondition of an event is the predicate $E \in P$, and the proposed inductive invariant is $I$. Let any additional assumptions on the memory (state) of the agent be captured by the predicate $A$. Let the \emph{context} or memory of the agent be $m\in M$ before the round (event) is executed, and $m'\in M$ after the round (event) is executed. The inductive invariant holds for an agent $i$ after an if
            $$(\myuin = i \wedge \mathit{Eval}(E,m)\wedge \mathit{Eval}(I,m)\wedge Eval(A,m'))\Rightarrow \mathit{Eval}(I,m').$$

 \rg{More analysis of conditional statements within events, and add the general statement for all agents.}

\subsubsection*{Lineform}
The executable $\lgname$ semantics is used to prove \inv{lineform} inductively, using the strategy explained at a high level in refsect{overview}.



We denote the variables $\mathit{Motion.Position}$ and $\mathit{Motion.Target}$ by $\mathit{mp}$ and $\mathit{mt}$ respectively,  and denote the value of agent $i$'s local copies of these variables before the event is executed by $\mathit{mp}_i$ and $\mathit{mt}_i$ respectively. The \emph{allread} variable $x[i]$ is denoted by $x_i$. The primed copies of these variables denote their values after a round (event execution and environment transition) has occured. Our tools ensure that only constraints with satisfiable premises are evaluated. For the \emph{Lineform} application, it has only one event \emph{TargetUpdate}, which is executed only when $E =\neg (\myuin = \NMAX - 1 \vee \myuin = 0)$ holds. $\myuin = 0 \wedge E$ is unsatisfiable, meaning these constraints will not be checked for agents $0$ and $\NMAX - 1$.

\rg{Add statement about how this proof holds even when the motion sensors and actuators can be seen as variables in $R$ and not required to be 2D}

The effect of the event (for agent $i$) is $E := mt_i' = (x_{i-1} + x_{i+1})/2  \wedge x_i' = mp_i$.  The assumption (as stated earlier) is $A := mp_i' \leq mt_i \wedge mp_i' \geq mp_i)$. \rg{Additionally, we need a constraint $F:= x_{i-1} \in [x_{min}, x_{max}] \wedge x_{i+1}\in [x_{min},x_{max}]$.} The invariant is $I: \mathit{mp}_i \in [x_{min}, x_{max}]$ and $I'$ denotes the invariant $\mathit{mp}_i' \in [x_{min}, x_{max}]$.  The overall constraint then becomes :
                   $E \wedge A \wedge F \wedge I \Rightarrow I'$, which we verified for models of size 3,4 and 5 using \K and Z3.
\rg{Insert table (checkmarks? running times?) here.}



