\section{verification}
\label{sec:verification}
\rg{round, program transition, event execution, $\delta$-transition are all defined at this point: program transition : events executed in some order, $\delta$-transition: simulataneous advancement of time, round = program + $\delta$-transition. }

Let $\rightarrow_{e}$ where $e$ is an event in the $\lgname$ program represent the sequence of $\stmtrule$ rules that correspond to the execution of event $e$. Given a system configuration $C$, we define the following:
 \begin{inparaenum}[(i)]
     \item $\Post(C,i,e)$ is the set of configurations which can be reached by agent $i$ executing event $e$ from a configuration in $C$.
     \item$\Post(C,i)$ is the set of configurations which can be reached by agent $i$ executing an event from a configuration in $C$.
     \item$\Post(C,p)$ is the set of configurations reached during a program transition, when agents execute their events in the order $p$, where $p$ is a sequence of agent $\mathit{pids}$.
     \item $\Post(C)$ is the union of $\Post(C,p)$ over all orders $p$.
     \item$\Final(C)$ is the set of configurations reached from $C$ \emph{after} a program transition.
 \end{inparaenum}
\vspace{1mm}
\begin{mdframed}
\footnotesize
\begin{align*}
    \Post (C,i,e) &= \{ c^\prime\mid \exists c\in \pwg,  \ \ c\rightarrow_{e} c^\prime \},\\
\Post(C,i) :=& \bigcup_e \Post(C,i,e),\\
\Post(C,(i_1,i_2,\ldots ,i_p)) := & \ \Post(\Post(C,i_1),(i_2,i_3,\ldots,i_p))\\ & \cup \Post(C,i_1)\\
\Post(C) :=& \bigcup_{p\in \mathit{perms}(\UINS)} \Post(C,p), \\
\Final(C) :=& \left\{ c\in \Post(C)\mid \forall i \in \UINS, c.L_i.\turn = \env \right\}.
\end{align*}
\end{mdframed}

Here $\mathit{perms}(\UINS)$ is the set of permutations of $\UINS$.
We define a function $\traj: \pwg \times \left[0,\delta\right]$, which represents the \emph{trajectory} of the system, or the intermediate values of the sensor ports during a $\delta$-transition. Given a $c\in \pwg, t\in \left[0,\delta\right]$, $\traj(c,t)$ represents the configuration at time $t$. $\pt(C)$ is  the set of configurations over the interval $[0,\delta]$.

$$\pt(C) := \left\{c^\prime \mid \exists c\in C, t\leq \delta , c^\prime = \traj(c,t)\right\}$$

The set of points reached by an $\delta$-transition at $\delta$ time from $C$ can be expressed as $\ft(C) := \Post_{[\delta,\delta]}(C)$. A \emph{frontier} set of configurations represents the set of configurations that can be reached from an initial configuration $C$ after completing rounds of execution. We define $\frontier(C,0) := C$ and,
$$\frontier(C,n) := \ft(\Final(\frontier(C,n-1))).$$

Finally, we are ready to define the set of \emph{reachable} configurations of a system. Given an initial set of configurations $C_0\subset\pwg$,

the set of states reachable with executions of length $n$ can be defined inductively as follows: $\Reach(C_0,0) := C_0$,
\begin{align*}
\Reach(C_0,n) &:= \Post(\frontier(C_0,n-1) \cup \pt(\Post(\frontier(C_0,n-1)))
\end{align*}

Given a configuration $c \in \pwg$, $c(\mathit{inv})$ represtnts the substitution of variables in $\mathit{inv}$ with their values from $c$.

 Formally, we say that $\beta$ is an inductive invariant if given a set of initial configurations of a system $C_0 \in \pwg$, and an arbitrary configuration $c \in \pwg$,  $$\forall c_0 \in C_0, c_0(\beta) \wedge c(\beta) \Rightarrow \forall c^\prime \in \Reach(c,1), c^\prime(\beta).$$ In other words, if a property holds true in the initial states of a system, and it can be proved to hold for all configurations reachable in one round from any configuration it is known to hold in, then it is an invariant of the system.


\begin{definition}
\label{def:ii}
A property $\beta$ is an inductive invariant of a system if given a set of initial configurations of the system $C_0$, and an arbitrary configuration $c\in \pwg$,
\begin{align*}
&\bigwedge_{c_0\in C_0}c_0(\beta) \wedge c(\beta) \Rightarrow\\ & \forall c' \in \Post(c), c'' \in c'(\beta)\wedge \forall c'' \in \pt(c') , c''(\beta)
\end{align*}
\end{definition}


%\begin{align}
%&\bigwedge_{c_0\in C_0} \eval(c_0, \mathit{inv})  \label{eq:iic1} \\
% &\bigwedge_j\bigwedge_i(\eval(c,\mathit{inv}))  \Rightarrow \eval(\Post_j(c,i),\mathit{inv}) \label{pc} \\
% & \eval(c,\mathit{inv}) \wedge c.\turn = \env \wedge t \in [0,\delta] \Rightarrow(\eval(\traj(c,t),\mathit{inv})). \label{ec}
%\end{align}
%%\fTBD{need help formatting this}
%%There are three parts to this definition:
This definition states that if that every initial configuration satisfies $\mathit{inv}$, and  program and $\delta$-transitions preserve it, then $\mathit{inv}$ is defined as an inductive invariant of the system.


We use a symbolic execution of the $\lgname$ semantics to compute $\Post(c)$. For an arbitrary program with arbitrary events, the set of reachable states computed takes into consideration every possible order of execution, every possible combination of events, but we exploit specific properties of our case study applications to reduce unnecessary reachability computation. \rg{We push the analysis of $\pt(c)$ into assumptions, which we can validate empirically in certain cases.}

     We prove an inductive invariant, for a \emph{specific number of agents}. \footnote{we can generalize the proof for an arbitrary number of agents manually}. The user specifies the desired inductive invariant along with any additional assumptions, which may include assumptions on properties such as the vehicle dynamics, or any functions used in the code. The semantics first generates and propagates \emph{constraints} on the variables determined by the effects of each event separately. We use bookkeeping to collect the constraints generated by the property specification along with the context to evaluate them as part of the configuration in \K. For instance, suppose the precondition of an event $e$ is the predicate $E$, and the proposed inductive invariant is $I$. Let any additional assumptions on the memory (state) of the agent be captured by the predicate $A$. The inductive invariant holds for an agent $i$ after this event if
            $$\mathit{pid} = i \wedge c(E)\wedge c(I)\wedge c'(A)\Rightarrow c(I),$$

for all $c' \in \Post(c,i,e)$.



 %\rg{Detailed analysis of conditional statements within events?}.

\subsubsection*{Lineform}
The executable $\lgname$ semantics is used to prove \inv{lineform} inductively, using the strategy explained at a high level in \refsect{overview}. Let us denote the variables $\mathit{Motion.Position}$ and $\mathit{Motion.Target}$ by $\mathit{mp}$ and $\mathit{mt}$ respectively,  and denote the value of agent $i$'s local copies of these variables before the event is executed by $\mathit{mp}_i$ and $\mathit{mt}_i$ respectively. The \emph{allread} variable $x[i]$ is denoted by $x_i$. The primed copies of these variables ($\mathit{mp_i', mt_i',x_i'}$) denote their values after a round (event execution and $\delta$-transition) has occured. For the \emph{Lineform} application, it has only one event \emph{TargetUpdate}, which is executed only when $\neg (\myuin = \NMAX - 1 \vee \myuin = 0)$ holds. $\myuin = 0 \wedge E$ is unsatisfiable, meaning these invariant is vacuously validated for the extremal robots.


Executing the effect of the event (for agent $i$) using \K semantics gives us the constraint $$E := mt_i' = (x_{i-1} + x_{i+1})/2  \wedge x_i' = mp_i$$.  The assumption (as stated earlier) is \begin{align*}A := &mp_i' \leq mt_i \wedge mp_i' \geq mp_i \\ &\wedge  x_{i-1} \in [x_{min}, x_{max}] \wedge x_{i+1}\in [x_{min},x_{max}].\end{align*} The invariant is $I: \mathit{mp}_i \in [x_{min}, x_{max}]$ and $I'$ denotes the invariant $\mathit{mp}_i' \in [x_{min}, x_{max}].$  The overall constraint then becomes $E \wedge A \wedge I \Rightarrow I',$. Now, given a configuration $c$, since there is only one event, $\Post(c,i,\mathit{TargetUpdate}) = \Post(c,i)$. Additionally, since given any two agents $i$ and $j$ do not write to the same variable, $\Post(\Post(c,i), j) = \Post(\Post(c,j),i)$. Therefore, we can consider a single order of execution.

\rg{discussion of numbers here}.

%The effect of the event (for agent $i$) is $E := mt_i' = (x_{i-1} + x_{i+1})/2  \wedge x_i' = mp_i$.  The assumption (as stated earlier) is $A := mp_i' \leq mt_i \wedge mp_i' \geq mp_i)$. \rg{Additionally, we need a constraint $F:= x_{i-1} \in [x_{min}, x_{max}] \wedge x_{i+1}\in [x_{min},x_{max}]$.} The invariant is $I: \mathit{mp}_i \in [x_{min}, x_{max}]$ and $I'$ denotes the invariant $\mathit{mp}_i' \in [x_{min}, x_{max}]$.  The overall constraint then becomes :
                   %$E \wedge A \wedge F \wedge I \Rightarrow I'$, which we verified for models of size 3,4 and 5 using \K and Z3.




