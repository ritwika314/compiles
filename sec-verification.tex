
\section{Formal analysis of \lgname programs}
\label{sec:verification}

\newcommand{\Ev}{\ensuremath{e}\xspace}
\newcommand{\EvCond}{\ensuremath{\mathit{Cond}}\xspace}
\newcommand{\EvBody}{\ensuremath{\mathit{Body}}\xspace}

%\rg{round, program transition, event execution, $\delta$-transition are all defined at this point: program transition : events executed in some order, $\delta$-transition: simulataneous advancement of time, round = program + $\delta$-transition. }
% connect to definition of e.
%make the post definition on a set.

We have built the semantics of $\lgname$ in the \K framework to enable decoupled analyses of discrete and dynamic parts of distributed multi-robot systems.
As discussed in the previous sections, the \emph{events} in an $\lgname$ program comprise the discrete computations in the system.
The effect of a robot $i$ executing event $\Ev \in \Event$ on a configuration $\gconfig \in \pwg$,
can be seen as a $\stmtrule$ application to  $\left\langle \gconfig.S, \gconfig.\lconfig{i}, \EvBody \right\rangle $,
where $\Ev$ is \emph{``eventName: {\normalfont\bf pre:} \EvCond\ {\normalfont\bf eff:} \EvBody''}.


\subsection{Reachable configurations}

Given a set of system configurations $\gset$, we define the functions using the semantic rules of \refsect{semantics}:
\begin{inparaenum}[(i)]
    \item $\Post_\Ev(\gconfig,i)$ returns the set of configurations obtained by robot $i$ executing event $\Ev \in \Event$ from a configuration $\gconfig$.
          \sayan{are events deterministic? Did we discuss somewhere?}
    \item $\Post(\gset,i)$ returns the set of configurations obtained by robot $i$ executing any event from a configuration in $\gset$.
    \item $\Post(\gset,\pvec)$ returns all configurations visited, when robots execute their events in the order $\pvec$,
          where $\pvec$ is a sequence of $p_i \in \UINS$.
    \item $\Post(\gset)$ is the union of $\Post(\gset,\pvec)$ over all orders $\pvec$.
    \item $\Final(\gset)$ is the set of configurations reached from $\gset$ \emph{after} a program transition.
\end{inparaenum}

\vspace{1mm}
\begin{mdframed}[
    innertopmargin=0pt,
    innerleftmargin=0pt, innerrightmargin=0pt
]
\footnotesize
\newcommand{\Skip}{\mathit{Skip}\xspace}
\begin{align*}
    \Post_\Ev(\gconfig,i) := \{& \gconfig' \mid \eec{\EvCond}{\gconfig.S, \gconfig.\lconfig{i}} \\
      & \land \left\langle \gconfig.S, \gconfig.\lconfig{i}, \EvBody \right\rangle \stmtrule \left\langle \gconfig'.S, \gconfig'.\lconfig{i}, \EndEvent \right\rangle\}, \\
    \Skip(\gconfig,i) := \{& \gconfig' \mid \left\langle \gconfig.S, \gconfig.\lconfig{i}, \EndEvent \right\rangle \stmtrule \left\langle \gconfig'.S, \gconfig'.\lconfig{i}, \EndEvent \right\rangle \} \\
    \Post(\gset,i) := & \bigcup_{\gconfig\in\gset} \left(\Skip(\gconfig, i) \cup \bigcup_{\Ev \in \Event} \Post_\Ev(\gconfig, i) \right),\\
    \Post(\gset,\pvec) := &
        \begin{cases}
            \emptyset, \text{ if } \pvec=()\\
            \Post(\Post(\gset,\pinit),\pvec'), \text{ if } \pvec=(\pinit, \pvec')\\
        \end{cases}\\
    \Post(\gset) := & \bigcup_{\pvec\in \mathit{perms}(\UINS)} \Post(\gset,\pvec), \\
    \Final(\gset) := & \left\{ \gconfig\in \Post(\gset)\mid \forall i \in \UINS, \gconfig.\lconfig{i}.\turn = \env \right\}.
\end{align*}
\end{mdframed}
where in a sequence $\pvec=(\pinit, \pvec')$, $\pinit$ refers to the first element of the sequence and $\pvec'$ refers to the rest of the sequence.
Also, $\mathit{perms}(\UINS)$ refers to the set of permutations of $\UINS$.

$\Final(\gset)$ returns the set of system configurations after a program transition.
Now we further define how to compute reachable system configurations after an environment transition.
Given the black-box function $f_i$ for each robot $i$,
we can define the function $\traj: \pwg \times \left[0,\delta\right] \mapsto \pwg$ to represent the \emph{trajectory} of the system during an environment transition.
$\traj$ is constructed by simply update all controller ports $\cp$ of all robots with their $f_i$.
In short,
\[
\gconfig' = \traj(\gconfig, t) \implies \forall i, \gconfig'.\lconfig{i}.cp = f_i(\gconfig.\lconfig{i}.cp, t)
\]
We then define the set of system configurations $\pt{t_1}{t_2}(\gset)$ reached in an interval $[t_1,t_2]$:
\[
\pt{t_1}{t_2}(\gset) := \left\{\gconfig' \mid \exists \gconfig\in \gset, t_1 \leq t\leq t_2 , \gconfig' = \traj(\gconfig,t)\right\}
\]
The set of points reached at the end of an environment transition from $\gset$ is denoted by  $\ft(\gset) := \pt{\delta}{\delta}(\gset)$.

Now to conform to our semantics, we carefully define the exact set of configurations
reached right at the end of each \emph{round} without transient configurations.
A \emph{frontier} set of configurations $\frontier(\gset, n)$ represents those configurations
that are reached from $\gset$ \emph{exactly when} $n$ rounds are completed.
Formally,
\[
\frontier(\gset,n) :=
    \begin{cases}
        \gset, \text{ if } n = 0\\
        \ft(\Final(\frontier(C,n-1))).
    \end{cases}
\]


Finally, given a set of configurations $\gset_0\subseteq\pwg$,
the set of all reachable states in $n$ rounds is defined inductively as follows:
\[
\Reach(\gset_0, n) :=
    \begin{cases}
        \gset_0, \text{ if } n = 0 \\[5pt]
        \Reach(\gset_0,n-1) \text{\hspace{1.8cm}otherwise} \\
        \hspace{0.5em} \cup\ \Post(\frontier(\gset_0,n-1))\\
        \hspace{0.5em} \cup\ \pt{0}{\delta}(\Final(\frontier(\gset_0,n-1))),\\
    \end{cases}
\]
Notice that all transient configurations during both program~(computed by $\Post$) and environment~(computed by $\pt{0}{\delta}$) transitions are included in $\Reach$.


\subsection{Invariant requirements}
\label{sec:inv-po}

\newcommand{\Inv}{\mathit{inv}\xspace}

An \emph{invariant} of a \lgname program is a safety property that holds in all reachable system configurations.
Invariant can be used to guarantee, for instance, that no two robots are ever within a specified radius of each other~(Collision avoidance),
or robots always stay within a designated area~(Geofencing).
Formally,
\begin{definition}
An invariant $\Inv$ is a predicate~(Boolean valued function) over a configuration $\gconfig$ such that,
given a set of initial configurations of the system $\gset_0$,
\[
\forall n\in\naturals, \forall\gconfig \in \Reach(\gset_0, n), \eec{\Inv}{\gconfig},
\]
where $\eec{\Inv}{\gconfig}$ represents evaluating $\Inv$ over $\gconfig$.
\end{definition}

\begin{figure}
\newcommand{\vbar}{{\normalfont\ |\ }}
\itshape
\begin{tabular}{l@{\ }r@{\ \ }l}
    Term   &   ::= & $\Var \vbar \Val \vbar \Cfield$                                           \\
           & \vbar & Term $+$ Term \vbar Term $\times$ Term                                    \\
           & \vbar & Term $-$ Term \vbar Term \slash Term                                      \\
    BExpr  &   ::= & Term $\geq$ Term \vbar Term $\leq$ Term                                   \\
           & \vbar & Term $=$ Term \vbar Term $>$ Term \vbar Term $<$ Term                     \\
           & \vbar & BExpr $\wedge$ BExpr \vbar BExpr $\vee$ BExpr                             \\
           & \vbar & $\neg$ BExpr \vbar BExpr $\Rightarrow$ BExpr                              \\
    $\Inv$ &   ::= & BExpr \vbar $\forall i \in \UINS, \Inv$ \vbar $\exists i \in \UINS, \Inv$
\end{tabular}

\caption{$\Inv$ specification syntax}\label{fig:inv-syntax}
\end{figure}


\begin{definition}
\label{def:ii}
A predicate $\mathit{inv}$ is an \emph{inductive invariant} of a system if given a set of initial configurations of the system $\gset_0$,
we can prove the following proof obligations~(POs):
\begin{gather}
\forall \gconfig_0\in \gset_0, \eec{\Inv}{\gconfig_0} \label{po:base}\tag{\textit{Base}}\\
\forall \gconfig \in \pwg, \eec{\Inv}{\gconfig} \Rightarrow \forall \gconfig' \in \Reach(\left\{\gconfig\right\},1), \eec{\Inv}{\gconfig'} \label{po:ind-hyp-orig}
\end{gather}
\end{definition}
This definition states that $\Inv$ is satisfied by the initial configuration(s) of a system~(\PO{po:base}),
and also by any configuration reached during one round from any configuration satisfying the property~(\PO{po:ind-hyp-orig}).
It is straightforward to prove that an inductive invariant is always an invariant by induction.

Our proposed proof strategy for the presented case studies is thus to prove
user-specified requirements are inductive invariants by discharging the proof obligations.
\PO{po:base} is mostly trivial.
We therefore focus on how to prove \PO{po:ind-hyp-orig}.
In particular, we \emph{decouple} the environment and program transition behaviors in $\Reach$,
and analyze each separately.
More precisely, \PO{po:ind-hyp-orig} can be restated by expanding $\Reach$ and $\frontier$ as $\forall \gconfig \in \pwg,$
\begin{gather}
\eec{\Inv}{\gconfig} \Rightarrow \forall \gconfig' \in \Post(\incurly{\gconfig}), \eec{\Inv}{\gconfig'}\label{po:ind-hyp-prog}\\
\small
\eec{\Inv}{\gconfig} \Rightarrow \forall \gconfig' \in \pt{0}{\delta}(\Final(\incurly{\gconfig})), \eec{\Inv}{\gconfig'}\label{po:ind-hyp-env}
\end{gather}

A major cause of state explosion in computing $\Post$ for \PO{po:ind-hyp-prog}
is the permutation of all possible orders for all robots
with reads/writes to shared contexts.
We therefore seek for a stronger and easier to prove proof obligation using the lemma below:
\begin{lemma}
   \label{lem:noninter}
Given any predicate $\varphi$,
for any configuration $c$ satisfying $\varphi$, the following always holds
\[
\small
\left(\bigwedge_{i\in \UINS}\bigwedge_{\Ev \in \Event} \forall \gconfig' \in \Post_\Ev(\gconfig, i), \eec{\varphi}{\gconfig'}\right)
    \Rightarrow \forall \gconfig' \in \Post(\incurly{\gconfig}), \eec{\varphi}{\gconfig'}
\]
\end{lemma}
We skip the detail proof for \lem{lem:noninter} here.
The idea is to simply expand the definition of $\Post$,
and because $\varphi$ is preserved before and after every event transition $\Post_\Ev$ of every robot,
the order of robots never cause violation of $\varphi$.
With \lem{lem:noninter}, we strengthen and rewrite \PO{po:ind-hyp-prog} as $\forall \gconfig, \gconfig' \in \pwg,$
\begin{equation}
\small
\bigwedge_{i\in \UINS}\bigwedge_{\Ev \in \Event} \eec{\Inv}{\gconfig} \land \gconfig' \in \Post_\Ev(\gconfig, i)
    \Rightarrow \eec{\Inv}{\gconfig'}\label{po:ind-hyp-event}
\end{equation}
Notice that we no longer have to enumerate all permutations.

We now discuss our approach to discharge \PO{po:ind-hyp-env}.
To further decouple program and environment transitions,
we expand $\pt{0}{\delta}$  and rewrite \PO{po:ind-hyp-env} as $\forall \gconfig, \gconfig', \gconfig'' \in \pwg,$
\begin{equation}\label{po:ind-hyp-traj}
\small
\begin{array}{l}
(\eec{\Inv}{\gconfig} \land\ \gconfig' \in \Final(\incurly{\gconfig})\\
\qquad  \land\ \forall t \in [0, \delta], \gconfig'' = \traj(\gconfig', t)) \Rightarrow \eec{\Inv}{\gconfig''}
\end{array}
\end{equation}
Obviously, \PO{po:ind-hyp-traj} requires a formalization of the dynamic behavior $\traj$ during environment transitions,
and it is a challenging research problem by itself.
As mentioned in \refsect{overview},
we introduce assumptions to abstract away the continuous dynamic behavior.
\begin{definition}
A \emph{\portasum} $A(\gconfig', \gconfig'')$ for $\traj$ is a predicate that
we can prove the following proof obligation that $\forall \gconfig', \gconfig'' \in \pwg,$
\begin{equation}\label{po:port-asm}\tag{\textit{Asm}}
(\forall t \in [0,\delta], \gconfig'' = \traj(\gconfig', t)) \Rightarrow A(\gconfig', \gconfig'')
\end{equation}
\end{definition}
The definition allows users to provide a relation that over-approximates $\traj$ regardless of the continuous time $t$.
\PO{po:port-asm} can be validated with the \toolname simulator or verified separately by other tools specialized for continuous dynamics.
Further, we know by definition $\Final(\incurly{\gconfig}) \subseteq \Post(\incurly{\gconfig})$,
we can apply \lem{lem:noninter} in a similar way.
Hence, with \PO{po:port-asm} and \lem{lem:noninter},
we can merge \PO{po:ind-hyp-event} and \PO{po:ind-hyp-traj} and strengthen as
$\forall \gconfig, \gconfig', \gconfig'' \in \pwg,$
\begin{equation}\label{po:ind}\tag{\textit{Ind}}
\small
\bigwedge_{i\in \UINS} \bigwedge_{\Ev \in \Event} \eec{\Inv}{\gconfig} \land \gconfig' \in \Post_\Ev(\gconfig, i)
\land A(\gconfig', \gconfig'')
\Rightarrow \eec{\Inv}{\gconfig''}
\end{equation}
where we can use our \K symbolic execution semantics to construct the symbolic post configuration
to represent $\gconfig' \in \Post_\Ev(\gconfig, i)$ for each event.

In the remainder of this section,
we demonstrate the verification of proposed invariants on three case studies.
In each case study, we describe the two proof obligations \PO{po:ind} and \PO{po:port-asm}
as well as the \portasum{}s in use.
For each case, we also show experiment results for proving/disproving the POs.


\subsection{Case Study: \LineForm}

\newcommand{\Mposi}{\mathit{M.pos}_i}
\newcommand{\Mtgti}{\mathit{M.tgt}_i}

In this section, we revisit the \LineForm program in \refsect{overview}.
As mentioned in \refsect{inv-po}, the symbolic post configuration generated by \K is representing a set of \emph{global configurations}.
For readability, we again present simplified formulas.
Following the notation in \PO{po:ind} and \PO{po:port-asm},
variables and \emph{primed copies} represents the variables in $\gconfig$, $\gconfig'$, and $\gconfig''$ respectively.

Symbolically executing the event \evname{TargetUpdate} (for robot $i$) generates the constraint:
\[
\small
E :=
\left(
\begin{array}{l}
    \neg (i = \NMAX - 1 \lor i = 0) \\
    \land\ \Mtgti' = (x[i-1] + x[i+1])/2 \land x'[i] = \Mposi \\
    \land\ \dots
\end{array}
\right)
\]
Notice that it starts with the precondition and $\Mtgti$ and $x[i]$ are updated according to the effect.
We omit the rest of the formula that ensures the values of unmodified variables are unchanged
such as $\Mposi'=\Mposi$ and $x'[j]=x[j]$ for $j\neq i$.
Additionally, a more accurate version of \asum{lineform-assume} in \refsect{overview} is
\[
A := \Mposi'' \in \rect(\Mposi', \Mtgti') \land \dots
\]
Similarly, the rest of the formula ensuring unchanged values is omitted.
Consequently, \PO{po:port-asm} becomes
\[
(\forall t \in [0,\delta], \Mposi'' = f(\Mposi', \Mtgti', t)) \Rightarrow A
\]
\chiao{Add table showing how often \PO{po:port-asm} is violated.}

The invariant for the current configuration~($\eec{\Inv}{\gconfig}$) is
\[
\small
I_{old}:= \Mposi \in \rect(x_{min}, x_{max}) \wedge x[i] \in \rect(x_{min}, x_{max})
\]
and the invariant over primed configuration~($\eec{\Inv}{\gconfig''}$) is
\[
\small
I_{new} := \Mposi'' \in \rect(x_{min}, x_{max}) \wedge x''[i] \in \rect(x_{min}, x_{max})
\]
Because there is only one event, \PO{po:ind} for \LineForm then becomes
\[
\bigwedge_{i\in \UINS} I_{old} \wedge E \wedge A \Rightarrow I_{new}
\]
Table \ref{tab:lineform} summarizes the verification of these constraints on systems with different $\NMAX$.

\begin{table}
    \scriptsize
 \centering
   \begin{tabular}{ l|   c c c c  }
 \hline
       (\NMAX) &\tb{dim} & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
   3   & 1 &4.90  &9.09   & \Checkmark  \\
 3   & 2 &4.19  &10.13   & \Checkmark  \\
 4    & 1 &4.79  &12.21  & \Checkmark   \\
4    & 2 &5.28  &12.49  & \Checkmark   \\
 4    & 3 &5.06  &12.77  & \Checkmark   \\
 5   & 1  &4.91  &18.46  & \Checkmark   \\
 5   & 2  &5.60  &18.91  & \Checkmark   \\
5   & 3  &5.42  &20.30  & \Checkmark   \\
10  & 1  &10.92   &32.34   & \Checkmark  \\
10  & 2  &10.96   &32.42   & \Checkmark  \\
10  & 3  &11.34   &33.61   & \Checkmark  \\
 15  & 1 &12.23  & 53.89   &\Checkmark
\end{tabular}
    \caption{ \small Summary of semantics based verification for \LineForm.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for construction of constraints and verification in Z3. Robots moving along a line are represented by \tb{dim} = 1, along a plane by \tb{dim} = 2, and in a 3D space by \tb{dim} = 3.}
            \label{tab:lineform}

\end{table}

We can define a $J$, a weaker invariant which simply constrains the position of each robot, and doesn't constrain the shared $x[i]$,
\[
J := \mathit{M.pos}_i \in \mathit{rect}[x_{min}, x_{max}]
\]
Table~\ref{tab:lineform1} shows the results we obtained without the proof obligations as assumptions,
and this weaker invariant on a system of robots moving in 2D.

\begin{table}
    \scriptsize
 \centering
   \begin{tabular}{ l|   c c c c  }
 \hline
       (\NMAX) &\tb{constraint} & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
   3   & $\Pr \wedge E\wedge I \Rightarrow I'$ &  &  & \emph{Unknown}  \\
 3   & $\Pr \wedge E \wedge J \Rightarrow J'$ &  &   & \emph{Unknown}  \\
 4    & $\Pr\wedge E \wedge I \Rightarrow I' $ &   &  &  \emph{Unknown} \\
4    & $\Pr \wedge E \wedge J\Rightarrow J'$ &  &  & \emph{Unknown}   \\
 4    & $\Pr \wedge E \wedge A \wedge I \Rightarrow I'$ &  &  & \emph{Unknown}   \\
\end{tabular}
    \caption{ \small Verification summary for weaker invariants on \LineForm. The \tb{constraint} column displays the induction hypothesis used in the verification. The verification procedure only tells us that the invariant is not inductive, it doesn't tell us whether the invariant doesn't hold, which is why we don't know whether the system is safe w.r.t the proposed invariant. }
            \label{tab:lineform1}
\end{table}

\newcommand{\Task}{\textsf{Task}\xspace}

\subsubsection{Case Study: \Task}
The problem statement for the \Task application is as follows: Given a set of (possibly heterogeneous) robots, a safety distance $d_s>0$, and a fixed sequence of points (tasks) $\mathit{list} = x_1, x_2, \ldots \in \reals^3$, it is required that: (a) every unvisited $x_i$ in the sequence is {\em visited\/} exactly by one robot; and (b) no two robots ever get closer than $d_s$.

We implemented a fairly straightforward solution shown in \reffig{taskapp}.
Robot $i$ looks for an unassigned task $x$ from $\mathit{list}$;
if there is a clear path to $x$ then $i$ assigns itself the task $x$. It shares its path with all other robots, and  visits $x$ following the path; once done it repeats the process.  We aim to prove the \emph{safety} of this application with respect to collisions among robots, i.e. \emph{no two robots ever get closer than $d_s$}.

\begin{figure}[t]
    \two{0.4}{0.6}
    {
    \lstinputlisting[language=NumKoord, lastline=20]{code/taskalloc.tex}
    }
    {
    \lstinputlisting[language=NumKoord, firstline=21, firstnumber=21]{code/taskalloc.tex}
    }
    \caption{ $\lgname$ code for robot $i$ for the Distributed Task Allocation}
    \label{fig:taskapp }
\end{figure}


This application has two events \begin{inparaenum} \item {Assign}, in which each robot tries to assign itself to an unassigned task with a clear path  and \item \emph{Complete}, which checks whether an robot has visited its assigned task. \end{inparaenum} The allread variable $\pathvar$ stores either the current path each robot is following to get to a task location, or the current position of a stationary robot. A path here is a list of points that a robot visits in sequence. The \Motion module drives the robot along a path, as directed by the position value set at its actuator port $\mathit{Motion.path}$. The sensor port $\mathit{Motion.planner}$ returns a path to the target of an unassigned task, and a (user-defined) function called $\mathit{pathIsClear}$ is used to determine whether the currently planned path is within $d_s$ distance of any of paths (or positions) in $\pathvar$.

\newcommand{\dist}{\mathit{dist}}
Suppose there is a function $\dist : [Point] \times [Point] \mapsto \mathbb{R}$, where $x$ and $y$ are paths (or positions) of the robots, that returns the minimum distance between $x$ and $y$.
\begin{invariant}
\label{inv:task}
\[\begin{split}
    \forall i,j, \in \UINS, \dist(M.pos_i, M.pos_j) \geq d_s \\ \land \dist(\pathvar[i], \pathvar[j]) \geq d_s
\end{split}
\]
\end{invariant}
\noindent

Computing the $\mathit{pathIsClear}$ function involves two nested loops over the length of each path, then computing the minimum distance between each path segment. Proving invariants over these loops is by itself a difficult (and well studied) problem, so our symbolic execution treats any user-defined functions as uninterpreted functions. We require proof obligations on the output of these functions. For any robot $i$ trying to assign itself to a task, we  assume that $\mathit{pathIsClear}(\mathit{sp}, \mathit{cp} ,i, \mathit{ds})$ returns true only if the shared paths the proposed path $\mathit{cp}$ is always more than $d_s$ distance of any of the shared paths (or positions). \footnote{ The index $i$ in the $\mathit{pathIsClear}$ function indicates that the previously shared path or position of the robot $i$ shouldn't be considered in the computation.}

\begin{proofob}
    \label{pathclear} There is an $\epsilon > 0$:
    $$\forall j \in \UINS, pathIsClear(sp, cp,  i, d_s) \wedge j \neq i \Rightarrow  \dist(sp[j], cp) \geq d_s + \epsilon$$
\end{proofob}


The second proof obligation is that an robot moves closely along its $\mathit{Motion.path}$ actuator whose value is denoted by $\mathit{M.path}$ until it finishes traversing the path. We also denote $\mathit{Motion.reached}$ by $\mathit{M.reached}$.
\begin{proofob}
        \label{stlinemotion}
    $$\mathit{on\_task}_i\wedge \neg \mathit{M.reached}_i \Rightarrow \dist(M.pos_i, sp[i]) \leq \epsilon $$
\end{proofob}

Since we do not want to deal with loop invariants, we verified this protocol for four tasks signified by $\incurly{t_1,t_2,t_3,t_4}$ and we unrolled the for loop iterating through the task list into a sequence of (nested) \emph{if-else} statements. The constraints on the symbolic post event configuration of the \emph{Assign} event for robot $i$ on picking $t_1$ generated by the \K executable semantics as follows: \begin{align*}E_{t_1} &:= \mathit{on\_task}_i' \wedge \mathit{curr\_path}_i' = \mathit{M.planner(t_1.target)} \\ &\wedge \pathvar[i]' = \mathit{curr\_path_i}' \wedge \mathit{M.path}_i' = \pathvar[i]' \\
  &\wedge (\bigwedge_j j\neq i \Rightarrow \pathvar[j]'= \pathvar[j]).
 \end{align*}

Similarly, we get $E_{t_2}$, $E_{t_3}$ and $E_{t_4}$ for the other tasks. For each task, an additional constraint capturing the proof obligation ~\ref{pathclear} on the function $\mathit{PathIsClear}$ is generated as follows:  $A_{t_1} := \forall j \in \UINS, j \neq id, \mathit{dist}(\pathvar[j], \mathit{curr\_path}_i') \geq d_s + \epsilon$ where $\epsilon$ is a positive constant. Similarly we have constraints $A_{t_2}, A_{t_3}$  and $A_{t_4}$ for the other tasks. When none of the tasks is picked, the post event configuration generated is $$ E_{none} :=\neg\mathit{on\_task}_i' \wedge \pathvar[i]' = M.pos_i $$. Since the positions of the robots don't change after the event, \inv{inv:task} for the current configuration for robot $i$ reduces to $$I: \forall j \in \UINS, j \neq i \Rightarrow \mathit{dist}(\pathvar[j], \pathvar[i]) \geq d_s  $$ and the invariant in the post event configuration is $$I' := \forall j \in \UINS, j \neq i \Rightarrow \mathit{dist}(\pathvar[j]', \pathvar[i]') \geq d_s  .$$

The induction hypothesis for event \emph{Assign} then becomes $$ \bigwedge_{i\in \UINS}\mathit{on\_task_i} \wedge \bigvee_{t_j}(E_{t_j} \wedge A_{t_j} \wedge  I) \Rightarrow I'.$$ The induction hypothesis for event \emph{Complete} is generated similarly (omitted here), and the overall induction hypothesis is a conjunction of the two.

Table \ref{tab:task} summarizes the verification of these constraints on systems with different number of robots.
\begin{table}
    \scriptsize
 \centering
   \begin{tabular}{ l|  c c c c  }
 \hline
 \tb{Benchmark}       & $\NMAX$ & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 Task       & 3     &9.90  &10.6   & \Checkmark  \\
 Task       & 4      &9.79  &11.78  & \Checkmark   \\
 Task       & 5      &9.91  &14.92  & \Checkmark   \\
Task        & 10     &12.92   &18.34   & \Checkmark  \\
\end{tabular}
    \caption{ \small Summary of semantics based verification for \Task.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for generation of constraints and verification in Z3 and $\NMAX$ is the number of robots in the system.}
    \label{tab:task}
\end{table}

\subsubsection{Case Study: Mapping}

 The problem requires a set of robots to collaboratively mark the position of static \emph{obstacles} within a given area $D$ quantized by a \emph{grid}, which any robot should avoid while moving in $D$.The key difference between distributed SLAM and this application is that we assume that the robots know their \emph{global coordinates} within the area of deployment. They are only attempting to map the static obstacles within this area. We assume that the only sensors available for sensing obstacles are LIDAR based, and the robots are constrained to move in a 2-D space.

 Our approach requires each robot to construct a \emph{local mapping} of the grid over $D$ using sensors, and update it using information from other robots shared via a \emph{global mapping}. Each mapping essentially maps a set $\qdom \subseteq D \cap \mathbb{Q}^2$ where $\qdom$ is a quantized representation of $D$, to 0 or 1 based on its occupancy.

Suppose there is a \emph{ground truth} function $\world_Q : Q \mapsto \left\{0,1\right\}$ that gives the actual occupancy of obstacles in this quantized arena. That is, $\forall p \in Q$,
\begin{align}
\world_Q(p) =
        \left\{
        \begin{array}{ll}
            1 & \mathit{if}\ p \ \mathit{is \ occupied}\\
            0 & \mathit{otherwise}.
        \end{array}
        \right.
\end{align}

\newcommand{\MotionWithScan}{\emph{MotionWithScan}\xspace}

In $\dmap$, the \MotionWithScan module provides a $\mathit{pscan}$ sensor used to read the LIDAR scan of the actual robot. The other sensors and actuators $\mathit{position,reached,planner,path}$ have the same functionality as that in the \Motion module.

\begin{figure}[t]
    \two{0.4}{0.6}
    {
    \lstinputlisting[language=NumKoord, lastline=20]{code/mapapp.tex}
    }
    {
    \lstinputlisting[language=NumKoord, firstline=21, firstnumber=21]{code/mapapp.tex}
    }
    \caption{ $\lgname$ code for robot $i$ for the Distributed Mapping Application}
    \label{fig:mapapp }
\end{figure}

 The $\lgname$ program corresponding to this solution has three \emph{events}: \emph{NewPoint, LUpdate, GUpdate}. The shared allwrite variable $\gmap$ is used to construct a shared map of obstacles within the domain $D$, and has type $\mathit{GridMap}$, which is a 2-D array representing a grid over $D$. The local variable $\lmap$ represents each robot's \emph{local} knowledge of the domain $D$, and has the same type as $D$. A robot executing the \emph{NewPoint} event, finds an unoccupied point to move to using a user defined function $\mathit{pickFrontierPos}$ and plans a path to it using $\mathit{MotionWithScan.planner}$. It then updates its $\lmap$ from the shared variable $\gmap$. The $\mathit{LUpdate}$ event updates the $\lmap$ with scanned sensor data while the robot is in motion, and the $\mathit{GUpdate}$ event updates the shared $\gmap$ with the updated $\lmap$ information corresponding to the scanned data.


Suppose we have a function $\mathit{snd}: GridMap \mapsto \mathbb{B}$, such that $\mathit{snd}(g)$ returns True if $g$ is consistent with the ground truth function $\world_Q$, and False otherwise. We want to prove that $\gmap$ as well as each robot $i$'s $\lmap_i$ is consistent with the ground truth function:
\begin{invariant}
    \label{inv:mapping}
    $\forall i \in \UINS \mathit{snd(\lmap_i)} \wedge \mathit{snd(\gmap)}$
\end{invariant}

For the \emph{NewPoint} event, the post event configuration for robot $i$ is $E:= \lmap_i' = \gmap \wedge \gmap' = \gmap$.
The induction hypothesis is $I:= \bigwedge_{i\in \UINS} \mathit{snd}(\lmap_i) \wedge \mathit{snd}(\gmap)$, and $I':= \bigwedge_{i\in \UINS} \mathit{snd}(\lmap_i') \wedge \mathit{snd}(\gmap')$ The overall constraint for this event along with its precondition is $$\bigwedge_{i\in \UINS}\neg\mathit{on\_path}\wedge E\wedge I\Rightarrow I'.$$

We also assume that the $\mathit{merge}$ function is such that given two maps satisfying $\mathit{snd}$, it returns a map satisfying $\mathit{snd}$. The specific proof obligation we have then is as follows:
\begin{proofob}
    \label{merge}
    $\forall i \in \UINS, \mathit{snd(\lmap_i)}\wedge \mathit{snd(\gmap)}\Rightarrow \mathit{snd(merge(\gmap,\lmap_i))}$,
\end{proofob}

For the event \emph{GUpdate}, we get the post event configuration for robot $i$ as $G:= \lmap_i' = \lmap_i \wedge \gmap' = \mathit{merge}(\gmap,\lmap_i)$. The proof obligation ~\ref{merge} is stated as \begin{align*}M:= \bigwedge_{i\in \UINS}, &\mathit{snd(\lmap_i)}\wedge \mathit{snd(\gmap)}\\ &\Rightarrow \mathit{snd(merge(\gmap,\lmap_i)).}\end{align*} The overall constraint for this event along with its precondition is therefore : $$\bigwedge_{i\in \UINS} \mathit{MWS}.reached \wedge G \wedge M \wedge I \Rightarrow I'$$. We omit the discussion for \emph{LUpdate} in the interest of space, as it follows along the lines of the previous constraints. It requires an additional proof obligation on the $\mathit{scanToMap}$ function and the consistency of the sensor data $\mathit{MotionWithScan.pscan}$ with the ground truth, along with unrolling the \emph{for-loop} to the number of sensor observations. The overall induction hypothesis is a conjunction of the three.

Table \ref{tab:map} summarizes the verification of these constraints on systems of different $\NMAX$ .
\begin{table}
    \label{tab:map}
    \scriptsize
 \centering
   \begin{tabular}{ l|  c c c c  }
 \hline
 \tb{Benchmark}       & \tb{robots}(N) & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 \dmap       & 3     &  &   & \Checkmark  \\
 \dmap      & 4      &  &  & \Checkmark   \\
 \dmap       & 5      &  &  & \Checkmark   \\
\dmap        & 10     &   &   & \Checkmark  \\
\end{tabular}
    \caption{ \small Summary of semantics based verification for \dmap.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for generation of constraints and verification in Z3 and \emph{robots}(N) is the number of robots in the system.}
\end{table}

