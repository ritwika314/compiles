\section{Formal analysis of $\lgname$ programs}
\label{sec:verification}
\rg{round, program transition, event execution, $\delta$-transition are all defined at this point: program transition : events executed in some order, $\delta$-transition: simulataneous advancement of time, round = program + $\delta$-transition. }

\subsection{Reachable Configurations}
Let $\rightarrow_{e}$ where $e$ is an event in the $\lgname$ program represent the sequence of $\stmtrule$ rules that correspond to the execution of event $e$. Given a system configuration $C$, we define the following:
 \begin{inparaenum}[(i)]
     \item $\Post(c,i,e)$ is the set of configurations which can be reached by agent $i$ executing event $e \in \Event$ from a configuration in $c$.
     \item$\Post(c,i)$ is the set of configurations which can be reached by agent $i$ executing an event from a configuration in $C$.
     \item$\Post(c,p)$ is the set of configurations reached during a program transition, when agents execute their events in the order $p$, where $p$ is a sequence of agent $\mathit{pids}$.
     \item $\Post(c)$ is the union of $\Post(c,p)$ over all orders $p$.
     \item$\Final(c)$ is the set of configurations reached from $c$ \emph{after} a program transition.
 \end{inparaenum}
\vspace{1mm}
\begin{mdframed}
\footnotesize
\begin{align*}
    \Post (c,i,e) &= \{ c^\prime\mid \ \ c\rightarrow_{e} c^\prime \},\\
\Post(c,i) :=& \bigcup_e \Post(c,i,e),\\
\Post(c,(i_1,i_2,\ldots ,i_p)) := & \ \Post(\Post(c,i_1),(i_2,i_3,\ldots,i_p))\\ & \cup \Post(C,i_1)\\
\Post(c) :=& \bigcup_{p\in \mathit{perms}(\UINS)} \Post(c,p), \\
\Final(c) :=& \left\{ c\in \Post(c)\mid \forall i \in \UINS, c.L_i.\turn = \env \right\}.
\end{align*}
\end{mdframed}

Here $\mathit{perms}(\UINS)$ is the set of permutations of $\UINS$.
We define a function $\traj: \pwg \times \left[0,\delta\right]$, which represents the \emph{trajectory} of the system, or the intermediate values of the sensor ports during a $\delta$-transition. Given a $c\in \pwg, t\in \left[0,\delta\right]$, $\traj(c,t)$ represents the configuration at time $t$. $\pt(C)$ is  the set of configurations over the interval $[0,\delta]$.

$$\pt(C) := \left\{c^\prime \mid \exists c\in C, t\leq \delta , c^\prime = \traj(c,t)\right\}$$

The set of points reached by an $\delta$-transition at $\delta$ time from $C$ can be expressed as $\ft(C) := \Post_{[\delta,\delta]}(C)$. A \emph{frontier} set of configurations represents the set of configurations that can be reached from an initial configuration $C$ after completing rounds of execution. We define $\frontier(C,0) := C$ and,
$$\frontier(C,n) := \ft(\Final(\frontier(C,n-1))).$$

Finally, we are ready to define the set of \emph{reachable} configurations of a system. Given an initial set of configurations $C_0\subset\pwg$,

the set of states reachable with executions of length $n$ can be defined inductively as follows: $\Reach(C_0,0) := C_0$,
\begin{align*}
\Reach(C_0,n) &:= \Post(\frontier(C_0,n-1) \cup \pt(\Post(\frontier(C_0,n-1)))
\end{align*}


\subsection{Inductive Invariants}
Given a configuration $c \in \pwg$, $c(\mathit{inv})$ represents the substitution of variables in $\mathit{inv}$ with their values from $c$.

 Formally, we say that $\beta$ is an inductive invariant if given a set of initial configurations of a system $C_0 \in \pwg$, and an arbitrary configuration $c \in \pwg$,  $$\forall c_0 \in C_0, c_0(\beta) \wedge c(\beta) \Rightarrow \forall c^\prime \in \Reach(c,1), c^\prime(\beta).$$ In other words, if a property holds true in the initial states of a system, and it can be proved to hold for all configurations reachable in one round from any configuration it is known to hold in, then it is an invariant of the system.


\begin{definition}
\label{def:ii}
A property $\beta$ is an inductive invariant of a system if given a set of initial configurations of the system $C_0$, and an arbitrary configuration $c\in \pwg$, it satisfies the following :
\begin{itemize}
    \item \emph{Initial condition} : $\bigwedge_{c_0\in C_0}c_0(\beta) $
\item  \emph{Induction Hypothesis} : $c(\beta) \Rightarrow \forall c' \in \Post(c), c'(\beta) \wedge \forall c'' \in \pt(\Final(c')) , c''(\beta)$
\end{itemize}
\end{definition}

\rg{In the latter part of this section we present three case studies to illustrate some of the formal analysis enabled by our prover module}. Our proposed proof strategy for the presented case studies is a \emph{decoupling} of the environment and program transition behaviors, and separate analysis. Formal analysis of the dynamic behavior of the system during environment transitions is a difficult problem by itself. We express the constraintS on the configurations reached during environment transitions as assumptionS. Formally, given a configuration $c\in \pwg$, we state $c(\beta) \Rightarrow \forall c'' \in \pt(\Final(c')) , c''(\beta)$ as an assumption $A$, which can be verified separately by other tools, and tested using the CyPhyhouse simulator. The induction hypothesis then simplifies to:

$$ c(\beta) \wedge A \Rightarrow \forall c' \in \Post(c), c'(\beta).$$




 A major source of nondeterminism in the behavior of these distributed programs with shared variables can be the order of writes in one round, and we observe that under specific circumstances, we can eliminate the necessity of exploring these behaviors during formal analysis. We formally state some of these observations below.

%For instance, if a $\lgname$ program has no shared variables or writes to shared variables, $\forall p_1, p_2 \in \mathit{perms}(\UINS),\Post(c,p_1) = \Post(c,p_2)$.



\begin{lemma}
    \label{noninter}
     Consider $\Event = \left\{e_1,e_2,\ldots, e_n\right\}$ and a proposed invariant $\beta$. Given that any of the events $e_i\in \Event$  either \begin{inparaenum} [(i)]\item contain only writes to an \emph{allread} variable, \item or at most \emph{atomic}writes to a shared variable, \item or no writes to a shared variable \end{inparaenum},
    $$ \bigwedge_{i\in \UINS}\bigwedge_{e \in \Event} \forall c' \in  \Post(c, i, e),  c'(\beta) \Leftrightarrow \forall c'' \in \Post(c), c''(\beta) $$
\end{lemma}
\begin{proof}
    The proof follows from the following two facts: the semantics of \emph{atomic} statements in $\lgname$ ensure that in a round, at most one agent can write to the shared variables contained in the atomic block, and the semantics of \emph{allread} variables in $\lgname$ ensure that an agent can only write to the index of the allread variable corresponding to its own $pid$.
\end{proof}

Given an event $e\in \Event$, we represent the precondition of an event as $\pre(e)$. The semantics ensures an event will not occur if the precondition is not satisfied. This, along with the premise of \lem{noninter}, allows us to sharpen the induction hypothesis further :
    $$ \bigwedge_{i\in \UINS} \bigwedge_{e \in \Event}  (c(\beta) \wedge \pre(e) \Rightarrow \forall c' \in  \Post(c, i, e) c'(\beta)) $$

 The remainder of this section demonstrates the verification of proposed invariants on three case studies.

%In practice, we prove an inductive invariant, for a \emph{specific number of agents}. \footnote{we can generalize the proof for an arbitrary number of agents manually}.

%(\rg{as we demonstrate in the following case studies})





%\begin{align}
%&\bigwedge_{c_0\in C_0} \eval(c_0, \mathit{inv})  \label{eq:iic1} \\
% &\bigwedge_j\bigwedge_i(\eval(c,\mathit{inv}))  \Rightarrow \eval(\Post_j(c,i),\mathit{inv}) \label{pc} \\
% & \eval(c,\mathit{inv}) \wedge c.\turn = \env \wedge t \in [0,\delta] \Rightarrow(\eval(\traj(c,t),\mathit{inv})). \label{ec}
%\end{align}
%%\fTBD{need help formatting this}
%%There are three parts to this definition:
%This definition states that if that every initial configuration satisfies $\mathit{inv}$, and  program and $\delta$-transitions preserve it, then $\mathit{inv}$ is defined as an inductive invariant of the system.







 %\rg{Detailed analysis of conditional statements within events?}.

\subsubsection*{Case Study: Lineform}
The executable $\lgname$ semantics is used to prove \inv{lineform} inductively, using the strategy explained at a high level in \refsect{overview}. Let us denote the variables $\mathit{Motion.Position}$ and $\mathit{Motion.Target}$ by $\mathit{mp}$ and $\mathit{mt}$ respectively,  and denote the value of agent $i$'s local copies of these variables before the event is executed by $\mathit{mp}_i$ and $\mathit{mt}_i$ respectively. The \emph{allread} variable $x[i]$ is denoted by $x_i$. The primed copies of these variables ($\mathit{mp_i', mt_i',x_i'}$) denote their values after a round (event execution and $\delta$-transition) has occured. For the \emph{Lineform} application, it has only one event \emph{TargetUpdate}, which is executed only when $\neg (\myuin = \UINS - 1 \vee \myuin = 0)$ holds. $\myuin = 0 \wedge E$ is unsatisfiable, meaning these invariant is vacuously validated for the extremal robots.


Executing the effect of the event (for agent $i$) using \K semantics gives us the constraint $$E := mt_i' = (x_{i-1} + x_{i+1})/2  \wedge x_i' = mp_i$$.  The assumption (as stated earlier) is \begin{align*}A := &mp_i' \leq mt_i \wedge mp_i' \geq mp_i \\ &\wedge  x_{i-1} \in [x_{min}, x_{max}] \wedge x_{i+1}\in [x_{min},x_{max}].\end{align*} The invariant is $I: \mathit{mp}_i \in [x_{min}, x_{max}]$ and $I'$ denotes the invariant $\mathit{mp}_i' \in [x_{min}, x_{max}].$  The overall constraint then becomes $E \wedge A \wedge I \Rightarrow I',$. Now, given a configuration $c$, since there is only one event, $\Post(c,i,\mathit{TargetUpdate}) = \Post(c,i)$. Additionally, since given any two agents $i$ and $j$ do not write to the same variable, $\Post(\Post(c,i), j) = \Post(\Post(c,j),i)$. Therefore, we can consider a single order of execution for computing $\Post(c)$.

 \begin{table}[!t]
\scriptsize
 \centering
  \caption{\small Summary of semantics based verification.  The \emph{Agents}(N) is the number of agents in the system, $T_R$ is the total verification time in seconds (K + Z3).}
  \label{tab:verif}
   %\begin{tabular}{|l|l|l|l|l|l|l|l|c|}
   \begin{tabular}{ l|  c c  c  }
 \hline
 \tb{Benchmark}       & \tb{Agents}(N) & $T_R$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 Lineform       & 3       &9.09   & \Checkmark  \\
Lineform       & 4      & 11.21  & \Checkmark   \\
 Lineform       & 5        &  12.41  & \Checkmark   \\
  Task       & 3       &14.12   & \Checkmark  \\
Task       & 4      & 18.28  & \Checkmark   \\
 Task       & 5        &  19.61  & \Checkmark   \\
 \hline
 \end{tabular}
 \end{table}

%The effect of the event (for agent $i$) is $E := mt_i' = (x_{i-1} + x_{i+1})/2  \wedge x_i' = mp_i$.  The assumption (as stated earlier) is $A := mp_i' \leq mt_i \wedge mp_i' \geq mp_i)$. \rg{Additionally, we need a constraint $F:= x_{i-1} \in [x_{min}, x_{max}] \wedge x_{i+1}\in [x_{min},x_{max}]$.} The invariant is $I: \mathit{mp}_i \in [x_{min}, x_{max}]$ and $I'$ denotes the invariant $\mathit{mp}_i' \in [x_{min}, x_{max}]$.  The overall constraint then becomes :
                   %$E \wedge A \wedge F \wedge I \Rightarrow I'$, which we verified for models of size 3,4 and 5 using \K and Z3.




