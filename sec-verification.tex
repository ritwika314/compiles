\section{Formal analysis of $\lgname$ programs}
\label{sec:verification}
%\rg{round, program transition, event execution, $\delta$-transition are all defined at this point: program transition : events executed in some order, $\delta$-transition: simulataneous advancement of time, round = program + $\delta$-transition. }
% connect to definition of e.
%make the post definition on a set.
We have built the semantics of $\lgname$  in the \K framework to enable decoupled analyses of discrete and dynamic parts of distributed multi-robot systems. As discussed in the previous sections, the \emph{events} in an $\lgname$ program comprise the discrete computations in the system. The effect of an agent $i$ executing event $e\in \Event$ on a configuration $c\in \pwg$, can be seen as a $\stmtrule$ application to  $\left\langle c.S, c.L, B \right\rangle $, where $e$ is ``eventName: pre: C eff: B''.
\marginpar{\scriptsize\sayan{fix fonts}}

\subsection{Reachable configurations}

 Given a set of system configurations $C$, we define the \sayan{functions using the semantic rules of Section~\ref{}}:
 \begin{inparaenum}[(i)]
     \item $\Post(C,i,e)$ returns the set of configurations that can be obtained by robot $i$ executing event $e \in \Event$ from a configuration in $C$.
  \marginpar{\scriptsize\sayan{are events deterministic? Did we discuss somewhere?}}
     \item$\Post(C,i)$ returns the set of configurations obtained by robot $i$ executing \sayan{any} event from a configuration in $C$.
     \item$\Post(C,p)$ returns all configurations visited, when robots execute their events in the order $p$, where $p$ is a sequence of robot $\mathit{pids}$.
     \item $\Post(C)$ is the union of $\Post(C,p)$ over all orders $p$.
     \item$\Final(C)$ is the set of configurations reached from $C$ \emph{after} a program transition.
 \end{inparaenum}
\vspace{1mm}
\begin{mdframed}
\footnotesize
\begin{align*}
    \Post (C,i,e) &= \{ c^\prime\mid \ \ \exists c \in C, \left\langle c.S, c.L, B \right\rangle \stmtrule \left\langle c^\prime.S, c^\prime.L, \cdot \right\rangle \},\\ &\mbox{ where B is the effect of }e.\\
\Post(C,i) :=& \bigcup_{e\sayan{\in??}} \Post(C,i,e),\\
\Post(C,p) := & \ \Post(\Post(C,\pinit), \prest)\\ & \cup \Post(C,\pinit)\\
\Post(C) :=& \bigcup_{p\in \mathit{perms}(\UINS)} \Post(C,p), \\
\Final(C) :=& \left\{ c\in \Post(C)\mid \forall i \in \UINS, c.L_i.\turn = \env \right\}.
\end{align*}
\end{mdframed}
\sayan{Write the 3rd function as Post(C,p) = Post(C,p[0]) if |p| =1 else = Post(Post(C,p[0]),p[1:]). As a 2 part recursive function definition. I am not sure about the notations, but you get the idea I hope. Does it make sense to introduce the types of C, p, i in the function definitions? Else, add it as a sentence belwo ``where $C\in C$ is a global confiduction, i $\in$ is a ...  }
Given a sequence (permutation) $p$, $\pinit$ refers to the first element (robot $\myuin$) of the permutation and $\prest$ refers to the rest of sequence. Also, $\mathit{perms}(\UINS)$ refers to the set of permutations of $\UINS$.

\sayan{Start new para. Say why we need to also model environment transition, and states reached at intermediate time points (1-2 sentencnes). Relate function traj to f.  }
We define a function $\traj: \pwg \times \left[0,\delta\right]$, which represents the \emph{trajectory} of the system, or the intermediate values of the sensor ports during a $\delta$-transition. Given $c\in \pwg, t\in \left[0,\delta\right]$, $\traj(c,t)$ represents the configuration at time $t$. $\pt{t_1}{t_2}(C)$ is the set of configurations reached by the system over the interval $[t_1,t_2]$.
$$\pt{t_1}{t_2}(C) := \left\{c^\prime \mid \exists c\in C, t_1 \leq t\leq t_2 , c^\prime = \traj(c,t)\right\}$$

The set of points reached by a $\delta$-transition at $\delta$ time from $C$ is denoted by  $\ft{\delta}(C) := \pt{\delta}{\delta}(C)$. A \emph{frontier} set of configurations represents the set of configurations that can be reached from an initial configuration $C$ after \emph{completing} rounds of execution. 
\sayan{rounds or one round?}
We define $\frontier(C,0) := C$ and,
$$\frontier(C,n) := \ft{\delta}(\Final(\frontier(C,n-1))).$$
\sayan{Again, use the 2 step if-then definition of this recursive function Fr and Reach.}


Finally, given a set of configurations $C_0\subset\pwg$, the set of states reachable in $n$ rounds can be defined inductively as $\Reach(C_0,0) := C_0$ and,
\begin{align*}
\Reach(C_0,n) := \Reach(C_0 &,n-1) \cup \Post(\frontier(C_0,n-1) \\ &\cup \pt{0}{\delta}(\Post(\frontier(C_0,n-1)))
\end{align*}
\sayan{Needs a sentence explaining the definition.}



\subsection{Invariant requirements}
An invariant of a system is a property that holds in all reachable configurations. Invariants can be used to specify, for instance, a safety property of a system such as no two robots are ever within a specified radius of each other. 
%\rg{The types of invariants allowed by our prover module are shown in appendix...}.
%define invariants, pointer to syntax
Given a configuration $c \in \pwg$, let $\eec{\mathit{inv}}{c}$ represent an \emph{evaluation} i.e. the substitution of variables in $\mathit{inv}$ with their values from $c$.
\sayan{what is inv? an expression a predicate? on what? Lets pull out some of these general notations about evaluation, permutations, etc. to be at the beginning of 5.}
%fix notation of evalution
 %Formally, we say that $\beta$ is an inductive invariant if given a set of initial configurations of a system $C_0 \in \pwg$, and an arbitrary configuration $c \in \pwg$,  $$\forall c_0 \in C_0, \eec{\mathit{inv}}{c_0} \wedge c(\beta) \Rightarrow \forall c^\prime \in \Reach(c,1), c^\prime(\beta).$$ In other words, if a property holds true in the initial states of a system, and it can be proved to hold for all configurations reachable in one round from any configuration it is known to hold in, then it is an invariant of the system.

\begin{definition}
\label{def:ii}
A property $\mathit{inv}$ is an \emph{inductive invariant} of a system if given a set of initial configurations of the system $C_0$, and an arbitrary configuration $c\in \pwg$, it satisfies the following :
$\bigwedge_{c_0\in C_0} \eec{\mathit{inv}}{c_0}\mbox{\textit{ (initial condition)}}$ and
$$\eec{\mathit{inv}}{c} \Rightarrow \forall c' \in \Reach(\left\{c\right\},1), \eec{\mathit{inv}}{c'} \mbox{\textit{ (induction hypothesis)}}.$$
\end{definition}
This definition states that property that is satisfied by the initial configuration(s) of a system, and also by any configuration reached during one round of execution from any configuration satisfying the property, is an invariant of the system.



\rg{In the latter part of this section we present three case studies to illustrate some of the formal analysis enabled by our prover module}.

Our proposed proof strategy for the presented case studies is a \emph{decoupling} of the environment and program transition behaviors, and separate analysis. Formal analysis of the dynamic behavior of the system during environment transitions is a difficult problem by itself. We express the constraints on the configurations reached during environment transitions as assumptions. The induction hypothesis can be restated as \begin{align*}\eec{\mathit{inv}}{c} \Rightarrow &(\forall c' \in \Post(\left\{c\right\}), \eec{\mathit{inv}}{c'} \wedge \\ &\forall c'' \in \pt{0}{\delta},(\Final(\incurly{c})) \eec{\mathit{inv}}{c''})\end{align*} We state $\eec{\mathit{inv}}{c} \Rightarrow \forall c'' \in \pt{0}{\delta}(\Final(\incurly{c})) $ as an assumption $A$, which can be verified separately by other tools, and tested using the CyPhyhouse simulator.

 A major source of nondeterminism in the behavior of these distributed programs with shared variables can be the order of writes to shared variables in one round, however, this is not a factor in proving inductive invariants.

\begin{lemma}
   \label{noninter}
Given an arbitrary (symbolic) configuration $c$ and an inductive invariant $\mathit{inv}$,
   {\small
   $$\bigwedge_{i\in \UINS}\bigwedge_{e \in \Event}  \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e)} \Leftrightarrow \forall c'' \in \Post(\left\{c\right\}), \eec{\mathit{inv}}{c}$$ }
\end{lemma}
\begin{proof}
Suppose that given an arbitrary configuration $c$, such that $\bigwedge_{i\in \UINS}\bigwedge_{e \in \Event} \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e)}$ holds true. Consider a permutation $\incurly{i_1,i_2,\ldots,i_{\NMAX}}$ of agents executing events $\incurly{e_1, e_2, \ldots , e_{\NMAX}}$ respectively in a program transition during a round, reaching configurations $c_1, c_2, \ldots, c_{\NMAX}$ respectively. By assumption, since $\Post(\incurly{c},i,e) = c_1$, $\eec{\mathit{inv}}{c_1}$. Since our assumption was about any arbitrary (symbolic) configuration $c$, the same argument therefore can be extended to all the configurations reached by the system during this program transition, i.e. $\forall c' \in \incurly{c_1, c_2, \ldots, c_n}, \eec{\mathit{inv}}{c}$.
\end{proof}

Given an event $e\in \Event$, we represent the precondition of an event as $\pre(e)$. The semantics ensures an event will not occur if the precondition is not satisfied. This and \lem{noninter} allows us to sharpen the induction hypothesis further :
    $$ \bigwedge_{i\in \UINS} \bigwedge_{e \in \Event}  (\eec{\mathit{inv}}{c} \wedge \pre(e) \wedge A \Rightarrow \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e) }).$$


The remainder of this section demonstrates the verification of proposed invariants on three case studies.

 %\rg{Detailed analysis of conditional statements within events?}.

\subsection{Case Study: Lineform}
 We use the executable $\lgname$ semantics to prove \inv{lineform} inductively, as discussed in \refsect{overview}. For the \emph{Lineform} application, it has only one event \emph{TargetUpdate}.

We represent the variables in the symbolic post configuration using \emph{primed copies} of the variables in the current configuration. Symbolically executing the effect of the event (for robot $i$) using \K semantics gives us the constraint $$E := \mathit{M.tgt_i}' = (x[i-1] + x[i+1])/2 \wedge x[i]' = \mathit{M.pos}_i,$$. We omitted the details of the $+$ operation, as it is overloaded to extend to vectors.

The assumption we make to prove the inductive invariant, following directly from \asum{lineform-assume} in \refsect{overview} is $$A := \mathit{M.pos}_i' \in \mathit{rect}[\mathit{M.pos}_i,\mathit{M.tgt}_i'] .$$
For agent $i$, Let the precondition of this event be denoted by $\mathit{Pr}:= \neg (i = \NMAX - 1 \vee i = 0)$.

%The premise of the induction hypothesis is unsatisfiable with the the precondition of this effect for the robots $0$ and $\NMAX-1$, meaning this invariant is vacuously validated for these robots.

The invariant for the current configuration is $$I: \mathit{M.pos}_i \in \mathit{rect}[x_{min}, x_{max}] \wedge x[i] \in \mathit{rect}[x_{min}, x_{max}]$$ and the invariant in the post event configuration is $$I' := \mathit{M.pos}_i' \in \mathit{rect}[x_{min}, x_{max}] \wedge x'[i] \in \mathit{rect}[x_{min}, x_{max}].$$
The overall induction hypothesis then becomes $$ \bigwedge_{i\in \UINS}\mathit{Pr} \wedge E \wedge A \wedge  I \Rightarrow I'.$$
Table \ref{tab:lineform} summarizes the verification of these constraints on systems of different sizes.

\begin{table}
    \label{tab:lineform}
    \scriptsize
 \centering
   \begin{tabular}{ l|   c c c c  }
 \hline
       (\NMAX) &\tb{dim} & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
   3   & 1 &4.90  &9.09   & \Checkmark  \\
 3   & 2 &4.19  &9.09   & \Checkmark  \\
 4    & 1 &4.79  &12.21  & \Checkmark   \\
4    & 2 &5.28  &12.49  & \Checkmark   \\
 4    & 3 &5.06  &12.77  & \Checkmark   \\
 5   & 1  &4.91  &18.46  & \Checkmark   \\
 5   & 2  &5.60  &18.91  & \Checkmark   \\
5   & 3  &5.42  &20.30  & \Checkmark   \\
10  & 1  &10.92   &32.34   & \Checkmark  \\
10  & 2  &10.96   &32.42   & \Checkmark  \\
10  & 3  &11.34   &33.61   & \Checkmark  \\
 15  & 1 &12.23  & 53.89   &\Checkmark

\end{tabular}
    \caption{ \small Summary of semantics based verification for \emph{Lineform}.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for construction of constraints and verification in Z3. Robots moving along a line are represented by \tb{dim} = 1, along a plane by \tb{dim} = 2, and in a 3D space by \tb{dim} = 3.}
\end{table}



% \begin{table}[!t]
%\scriptsize
% \centering
%  \caption{\small Summary of semantics based verification.  The \emph{robots}(N) is the number of robots in the system, $T_R$ is the total verification time in seconds (K + Z3).}
%  \label{tab:verif}
%   %\begin{tabular}{|l|l|l|l|l|l|l|l|c|}
%   \begin{tabular}{ l|  c c  c  }
% \hline
% \tb{Benchmark}       & \tb{robots}(N) & $T_R$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
% Lineform       & 3       &9.09   & \Checkmark  \\
%Lineform       & 4      & 11.21  & \Checkmark   \\
% Lineform       & 5        &  12.41  & \Checkmark   \\
%  Task       & 3       &14.12   & \Checkmark  \\
%Task       & 4      & 18.28  & \Checkmark   \\
% Task       & 5        &  19.61  & \Checkmark   \\
% \hline
% \end{tabular}
% \end{table}

%The effect of the event (for robot $i$) is $E := mt_i' = (x_{i-1} + x_{i+1})/2  \wedge x_i' = mp_i$.  The assumption (as stated earlier) is $A := mp_i' \leq mt_i \wedge mp_i' \geq mp_i)$. \rg{Additionally, we need a constraint $F:= x_{i-1} \in [x_{min}, x_{max}] \wedge x_{i+1}\in [x_{min},x_{max}]$.} The invariant is $I: \mathit{mp}_i \in [x_{min}, x_{max}]$ and $I'$ denotes the invariant $\mathit{mp}_i' \in [x_{min}, x_{max}]$.  The overall constraint then becomes :
                   %$E \wedge A \wedge F \wedge I \Rightarrow I'$, which we verified for models of size 3,4 and 5 using \K and Z3.

\newcommand{\Task}{\textsf{Task}\xspace}

\subsubsection{Case Study: \Task}
The problem statement for the \Task application is as follows: {\small \em \Task: Given a set of (possibly heterogeneous) robots, a safety distance $d_s>0$, and a fixed sequence of points (tasks) $\mathit{list} = x_1, x_2, \ldots \in \reals^3$, it is required that: (a) every unvisited $x_i$ in the sequence is {\em visited\/} exactly by one robot; and (b) no two robots ever get closer than $d_s$.\/}

The $\lgname$ program used to solve this problem in this paper implements a fairly straightforward solution shown in \reffig{fig:taskapp}. Robot $i$ looks for an unassigned task $x$ from $\mathit{list}$; if there is a clear path to $x$ then $i$ assigns itself the task $x$. It shares its path with all other robots, and  visits $x$ following the path; once done it repeats the process.  We aim to prove the \emph{safety} of this application with respect to collisions among agents, i.e. \emph{no two robots ever get closer than $d_s$}.

\begin{figure}[t]
    \two{0.4}{0.6}
    {
    \lstinputlisting[language=NumKoord, lastline=20]{code/taskalloc.tex}
    }
    {
    \lstinputlisting[language=NumKoord, firstline=21, firstnumber=18]{code/taskalloc.tex}
    }
    \caption{ $\lgname$ code for robot $i$ for the Distributed Task Allocation}
    \label{fig:taskapp }
\end{figure}


This application has two events \begin{inparaenum} \item {Assign}, in which each agent tries to assign itself to an unassigned task with a clear path  and \item \emph{Complete}, which checks whether an agent has visited its assigned task. \end{inparaenum} The robots use a shared allread variable $\pathvar$ to communicate the current path they are following to get to a task location, or their current position if they are stationary. A path here is a list of points that the robot visits in sequence. The \Motion module drives the robot along a path, as directed by the position value set at its actuator port $\mathit{Motion.path}$. The sensor port $\mathit{Motion.planner}$ returns a path to the target of an unassigned task, and a (user-defined) function called $\mathit{pathIsClear}$ is used to determine whether the currently planned path is within $d_s$ distance of any of paths (or positions) in $\pathvar$.

\newcommand{\dist}{\mathit{dist}}
Suppose there is a function $\dist : [Point] \times [Point] \mapsto \mathbb{R}$, where $x$ and $y$ are either paths or positions of the robots, that returns the minimum distance between $x$ and $y$.
\begin{invariant}
\label{inv:task}
\[\begin{split}
    \forall i,j, \in \UINS, \dist(M.pos_i, M.pos_j) \geq d_s \\ \land \dist(\pathvar[i], \pathvar[j]) \geq d_s
\end{split}
\]
\end{invariant}
\noindent

Computing the $\mathit{pathIsClear}$ function,involves two nested loops over the length of each path, computing the minimum distance between each path segment. Proving invariants over these loops is by itself a difficult (and well studied) problem, so our symbolic execution treats any user-defined functions as uninterpreted functions. We require assumptions on the output of these functions. For any agent $i$ trying to assign itself to a task, we  assume that $\mathit{pathIsClear}(\mathit{sp}, \mathit{cp} ,i, \mathit{ds})$ returns true only if the shared paths the proposed path $\mathit{cp}$ never comes within $d_s$ distance of any of the shared paths (or positions).

\begin{assumption}
    \label{pathclear} There is an $\epsilon > 0$:
    $$\forall j \in \UINS, pathIsClear(sp, cp,  i, d_s) \wedge j \neq i \Rightarrow  \dist(sp[j], cp) \geq d_s + \epsilon$$
\end{assumption}

 The index $i$ in the $\mathit{pathIsClear}$ function indicates that the previously shared path or position of the agent $i$ shouldn't be considered in the computation.

The second assumption we make is that an agent moves closely along its $\mathit{Motion.path}$ actuator whose value is denoted by $\mathit{M.path}$ until it finishes traversing the path. We also denote $\mathit{Motion.reached}$ by $\mathit{M.reached}$.
\begin{assumption}
        \label{stlinemotion}
    $$\mathit{on\_task}_i\wedge \neg \mathit{M.reached}_i \Rightarrow \dist(M.pos_i, sp[i]) \leq \epsilon $$
\end{assumption}

We verified this protocol for four tasks signified by $\incurly{t_1,t_2,t_3,t_4}$ and, we unrolled the for loop iterating through the task list into a sequence of (nested) \emph{if-else} statements. The updates to the symbolic post event configuration of the \emph{Assign} event for agent $i$ on picking $t_1$ are captured by the \K executable semantics as follows: \begin{align*}E_{t_1} &:= \mathit{on\_task}_i' \wedge \mathit{curr\_path}_i' = \mathit{M.planner(t_1.target)} \\ &\wedge \pathvar[i]' = \mathit{curr\_path_i}' \wedge \mathit{M.path}_i' = \pathvar[i]' \\
  &\wedge (\bigwedge_j j\neq i \Rightarrow \pathvar[j]'= \pathvar[j] )
 \end{align*}
Similarly, we get $E_{t_2}$, $E_{t_3}$ and $E_{t_4}$ for the other tasks. For $t_1$, an additional constraint capturing \asum{pathclear} on the function $\mathit{PathIsClear}$ is generated as follows :  $A_{t_1} := \forall j \in \UINS, j \neq id, \mathit{dist}(\pathvar[j], \mathit{curr\_path}_i') \geq d_s + \epsilon$ where $\epsilon$ is a positive constant. Similarly we have constraints $A_{t_2}, A_{t_3}$  and $A_{t_4}$ for the other tasks. When none of the tasks is picked, the post event configuration generated is $$ E_{none} :=\mbox{!}\mathit{on\_task}_i' \wedge \pathvar[i]' = M.pos_i $$. Since the positions of the robots don't change after the event, \inv{inv:task} for the current configuration for agent $i$ reduces to $$I: \forall j \in \UINS, j \neq i \Rightarrow \mathit{dist}(\pathvar[j], \pathvar[i]) \geq d_s  $$ and the invariant in the post event configuration is $$I' := \forall j \in \UINS, j \neq i \Rightarrow \mathit{dist}(\pathvar[j]', \pathvar[i]') \geq d_s  .$$

The induction hypothesis for event \emph{Assign} then becomes $$ \bigwedge_{i\in \UINS}\mathit{on\_task_i} \wedge \bigvee_{t_j}(E_{t_j} \wedge A_{t_j} \wedge  I) \Rightarrow I'.$$ The induction hypothesis for event \emph{Complete} is generated similarly, and omitted here, and the overall induction hypothesis is a conjunction of the two.


Table \ref{tab:task} summarizes the verification of these constraints on systems of different $N_sys$ .
\begin{table}
    \label{tab:task}
    \scriptsize
 \centering
   \begin{tabular}{ l|  c c c c  }
 \hline
 \tb{Benchmark}       & \tb{robots}(N) & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 Task       & 3     &9.90  &10.6   & \Checkmark  \\
 Task       & 4      &9.79  &11.78  & \Checkmark   \\
 Task       & 5      &9.91  &14.92  & \Checkmark   \\
Task        & 10     &12.92   &18.34   & \Checkmark  \\
\end{tabular}
    \caption{ \small Summary of semantics based verification for \Task.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for generation of constraints and verification in Z3 and \emph{robots}(N) is the number of robots in the system.}
\end{table}

\subsubsection{Case Study: Mapping}

 The problem requires a set of robots to collaboratively mark the position of static \emph{obstacles} within a given area $D$ quantized by a \emph{grid}, which any robot should avoid while moving in $D$.The key difference between distributed SLAM and this application is that we assume that the robots know their \emph{global coordinates} within the area of deployment. They are only attempting to map the static obstacles within this area. We assume that the only sensors available for sensing obstacles are LIDAR based, and the robots are constrained to move in a 2-D space.


 Our approach requires each robot to construct a \emph{local mapping} of the grid over $D$ using sensors, and update it using information from other robots shared via a \emph{global mapping}. \footnote{A formalization of this problem is provided in full in the supplementary materials. }

\newcommand{\MotionWithScan}{\emph{MotionWithScan}\xspace}

In $\dmap$, the \MotionWithScan module provides a $\mathit{pscan}$ sensor used to read the LIDAR scan of the actual robot. The other sensors and actuators $\mathit{position,reached,planner,path}$ have the same functionality as that in the \Motion module.

 The $\lgname$ program corresponding to this solution has three \emph{events}: \emph{NewPoint, LUpdate, GUpdate}. The shared allwrite variable $\gmap$ is used to construct a shared map of obstacles within the domain $D$, and has type $\mathit{GridMap}$, which is a 2-D array representing a grid over $D$. The local variable $\lmap$ represents each robot's \emph{local} knowledge of the domain $D$, and has the same type as $D$. A robot executing the \emph{NewPoint} event, finds an unoccupied point to move to using a user defined function $\mathit{pickFrontierPos}$ and plans a path to it using $\mathit{MotionWithScan.planner}$. It then updates its $\lmap$ from the shared variable $\gmap$. The $\mathit{LUpdate}$ event updates the $\lmap$ with scanned sensor data while the robot is in motion, and the $\mathit{GUpdate}$ event updates the shared $\gmap$ with the updated $\lmap$ information corresponding to the scanned data.




