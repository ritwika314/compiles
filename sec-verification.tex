
\section{Formal analysis of $\lgname$ programs}
\label{sec:verification}

\newcommand{\Ev}{\ensuremath{e}\xspace}
\newcommand{\EvCond}{\ensuremath{\mathit{Cond}}\xspace}
\newcommand{\EvBody}{\ensuremath{\mathit{Body}}\xspace}

%\rg{round, program transition, event execution, $\delta$-transition are all defined at this point: program transition : events executed in some order, $\delta$-transition: simulataneous advancement of time, round = program + $\delta$-transition. }
% connect to definition of e.
%make the post definition on a set.

We have built the semantics of $\lgname$ in the \K framework to enable decoupled analyses of discrete and dynamic parts of distributed multi-robot systems.
As discussed in the previous sections, the \emph{events} in an $\lgname$ program comprise the discrete computations in the system.
The effect of a robot $i$ executing event $\Ev \in \Event$ on a configuration $\gconfig \in \pwg$,
can be seen as a $\stmtrule$ application to  $\left\langle \gconfig.S, \gconfig.\lconfig{i}, \EvBody \right\rangle $,
where $\Ev$ is \emph{``eventName: {\normalfont\bf pre:} \EvCond\ {\normalfont\bf eff:} \EvBody''}.


\subsection{Reachable configurations}

Given a set of system configurations $\gset$, we define the functions using the semantic rules of \refsect{semantics}:
\begin{inparaenum}[(i)]
    \item $\Post_\Ev(\gconfig,i)$ returns the set of configurations obtained by robot $i$ executing event $\Ev \in \Event$ from a configuration $\gconfig$.
    \marginpar{\scriptsize\sayan{are events deterministic? Did we discuss somewhere?}}
    \item $\Post(\gset,i)$ returns the set of configurations obtained by robot $i$ executing any event from a configuration in $\gset$.
    \item $\Post(\gset,\pvec)$ returns all configurations visited, when robots execute their events in the order $\pvec$,
          where $\pvec$ is a sequence of $p_i \in \UINS$.
    \item $\Post(\gset)$ is the union of $\Post(\gset,\pvec)$ over all orders $\pvec$.
    \item $\Final(\gset)$ is the set of configurations reached from $\gset$ \emph{after} a program transition.
\end{inparaenum}

\vspace{1mm}
\begin{mdframed}[
    innertopmargin=0pt,
    innerleftmargin=0pt, innerrightmargin=0pt
]
\footnotesize
\newcommand{\Skip}{\mathit{Skip}\xspace}
\begin{align*}
    \Post_\Ev(\gconfig,i) := \{& \gconfig' \mid \eec{\EvCond}{\gconfig.S, \gconfig.\lconfig{i}} \\
      & \land \left\langle \gconfig.S, \gconfig.\lconfig{i}, \EvBody \right\rangle \stmtrule \left\langle \gconfig'.S, \gconfig'.\lconfig{i}, \EndEvent \right\rangle\}, \\
    \Skip(\gconfig,i) := \{& \gconfig' \mid \left\langle \gconfig.S, \gconfig.\lconfig{i}, \EndEvent \right\rangle \stmtrule \left\langle \gconfig'.S, \gconfig'.\lconfig{i}, \EndEvent \right\rangle \} \\
    \Post(\gset,i) := & \bigcup_{\gconfig\in\gset} \left(\Skip(\gconfig, i) \cup \bigcup_{\Ev \in \Event} \Post_\Ev(\gconfig, i) \right),\\
    \Post(\gset,\pvec) := &
        \begin{cases}
            \emptyset, \text{ if } \pvec=()\\
            \Post(\Post(\gset,\pinit),\pvec'), \text{ if } \pvec=(\pinit, \pvec')\\
        \end{cases}\\
    \Post(\gset) := & \bigcup_{\pvec\in \mathit{perms}(\UINS)} \Post(\gset,\pvec), \\
    \Final(\gset) := & \left\{ \gconfig\in \Post(\gset)\mid \forall i \in \UINS, \gconfig.\lconfig{i}.\turn = \env \right\}.
\end{align*}
\end{mdframed}
where in a sequence $\pvec=(\pinit, \pvec')$, $\pinit$ refers to the first element of the sequence and $\pvec'$ refers to the rest of the sequence.
Also, $\mathit{perms}(\UINS)$ refers to the set of permutations of $\UINS$.

$\Final(\gset)$ returns the set of system configurations after a program transition.
Now we further define how to compute reachable system configurations after an environment transition.
Given the black-box function $f_i$ for each robot $i$,
we can define the function $\traj: \pwg \times \left[0,\delta\right] \mapsto \pwg$ to represent the \emph{trajectory} of the system during an environment transition.
$\traj$ is constructed by simply update all controller ports $\cp$ of all robots with their $f_i$.
In short,
\[
\gconfig' = \traj(\gconfig, t) \implies \forall i, \gconfig'.\lconfig{i}.cp = f_i(\gconfig.\lconfig{i}.cp, t)
\]
We then define the set of system configurations $\pt{t_1}{t_2}(\gset)$ reached in an interval $[t_1,t_2]$:
\[
\pt{t_1}{t_2}(\gset) := \left\{\gconfig' \mid \exists \gconfig\in \gset, t_1 \leq t\leq t_2 , \gconfig' = \traj(\gconfig,t)\right\}
\]
The set of points reached at the end of an environment transition from $\gset$ is denoted by  $\ft(\gset) := \pt{\delta}{\delta}(\gset)$.

Now to conform to our semantics, we carefully define the exact set of configurations
reached right at the end of each \emph{round} without transient configurations.
A \emph{frontier} set of configurations $\frontier(\gset, n)$ represents those configurations
that are reached from $\gset$ \emph{exactly when} $n$ rounds are completed.
Formally,
\[
\frontier(\gset,n) :=
    \begin{cases}
        \gset, \text{ if } n = 0\\
        \ft(\Final(\frontier(C,n-1))).
    \end{cases}
\]


Finally, given a set of configurations $\gset_0\subseteq\pwg$,
the set of all reachable states in $n$ rounds is defined inductively as follows:
\[
\Reach(\gset_0, n) :=
    \begin{cases}
        \gset_0, \text{ if } n = 0 \\[5pt]
        \Reach(\gset_0,n-1) \text{\hspace{2cm}otherwise} \\
        \quad \cup\ \pt{0}{\delta}(\Post(\frontier(\gset_0,n-1))),\\
    \end{cases}
\]
Notice that all transient configurations during both program~(computed by $\Post$) and environment~(computed by $\pt{0}{\delta}$) transitions are included in $\Reach$.


\subsection{Invariant requirements}

\newcommand{\Inv}{\mathit{inv}\xspace}

An \emph{invariant} of a \lgname program is a safety property that holds in all reachable system configurations.
Invariant can be used to guarantee, for instance, that no two robots are ever within a specified radius of each other~(Collision avoidance),
or robots always stay within a designated area~(Geofencing).
Formally,
\begin{definition}
An invariant $\Inv$ is a predicate~(Boolean valued function) over a configuration $\gconfig \in \pwg$ such that,
given a set of initial configurations of the system $\gset_0$
\[
\forall n\in\naturals, \forall\gconfig \in \Reach(\gset_0, n), \eec{\Inv}{\gconfig},
\]
where $\eec{\Inv}{\gconfig}$ represents evaluating $\Inv$ over $\gconfig$.
\end{definition}
\chiao{Syntax for defining $\Inv$ as logic formulas?}
\newcommand{\vbar}{{\normalfont\ |\ }}

\begin{figure}
\itshape
\begin{tabular}{lrl}
   Term & ::= &  $\Var \vbar \Val \vbar \Cfield$ \vbar \\
        &     &  Term $+$ Term \vbar Term $\times$ Term \vbar \\
        &     &  Term $-$ Term \vbar Term \slash Term\\
   BExpr & ::= & Term $\geq$ Term \vbar Term $\leq$ Term \vbar \\
         &     & Term $=$ Term \vbar Term $>$ Term \vbar Term $<$ Term \vbar \\
         &      & BExpr $\wedge$ BExpr \vbar BExpr $\vee$ BExpr \vbar\\
         &      & $\neg$ BExpr \vbar BExpr $\Rightarrow$ BExpr \\
   $\Inv$ & ::= & BExpr \vbar $\forall i \in \UINS, \Inv$ \vbar $\exists i \in \UINS, \Inv$
\end{tabular}

\caption{$\Inv$ specification syntax}\label{fig:inv-syntax}
\end{figure}



\begin{definition}
\label{def:ii}
A predicate $\mathit{inv}$ is an \emph{inductive invariant} of a system if given a set of initial configurations of the system $\gset_0$,
it satisfies the following:
\begin{gather}
\forall \gconfig_0\in \gset_0, \eec{\Inv}{\gconfig_0}\\
\forall \gconfig \in \pwg, \eec{\Inv}{\gconfig} \Rightarrow \forall \gconfig' \in \Reach(\left\{\gconfig\right\},1), \eec{\Inv}{\gconfig'} \label{def:ind-hyp}
\end{gather}
\end{definition}
This definition states that property $\Inv$ is satisfied by the initial configuration(s) of a system,
and also by any configuration reached during one round from any configuration satisfying the property.
It is straightforward to prove that an inductive invariant is always an invariant by induction.

Our proposed proof strategy for the presented case studies is thus to prove
user-specified requirements are inductive invariants.
In addition, we \emph{decouple} the environment and program transition behaviors in $\Reach$,
and analyze each separately.
Formal analysis of the dynamic behavior of the system during environment transitions is a difficult problem by itself.
We express the constraints on the configurations reached during environment transitions as assumptions.
Criterion~\eqref{def:ind-hyp} can be expanded and simplified as:
\begin{equation}\label{def:ind-hyp-env}
\eec{\Inv}{\gconfig} \Rightarrow \forall \gconfig' \in \pt{0}{\delta}(\Post(\incurly{\gconfig})), \eec{\Inv}{\gconfig'}
\end{equation}
We state Criterion~\eqref{def:ind-hyp-env} as an assumption $A$,
which can be verified separately by other tools, and tested using the \toolname simulator.

A major source of nondeterminism in the behavior of these distributed programs with shared variables
can be the order of writes to shared variables in one round,
however, this is not a factor in proving inductive invariants.
\begin{lemma}
   \label{noninter}
Given an arbitrary (symbolic) configuration $c$ and an inductive invariant $\mathit{inv}$,
   {\small
   $$\bigwedge_{i\in \UINS}\bigwedge_{e \in \Event}  \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e)} \Leftrightarrow \forall c' \in \Post(\left\{c\right\}), \eec{\mathit{inv}}{c'}$$ }
\end{lemma}
\begin{proof}
Suppose that given an arbitrary configuration $c$, such that $\bigwedge_{i\in \UINS}\bigwedge_{e \in \Event} \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e)}$ holds true. Consider a permutation $\incurly{i_1,i_2,\ldots,i_{\NMAX}}$ of robots executing events $\incurly{e_1, e_2, \ldots , e_{\NMAX}}$ respectively in a program transition during a round, reaching configurations $c_1, c_2, \ldots, c_{\NMAX}$ respectively. By assumption, since $\Post(\incurly{c},i,e) = c_1$, $\eec{\mathit{inv}}{c_1}$. Since our assumption was about any arbitrary (symbolic) configuration $c$, the same argument therefore can be extended to all the configurations reached by the system during this program transition, i.e. $\forall c' \in \incurly{c_1, c_2, \ldots, c_n}, \eec{\mathit{inv}}{c}$.
\end{proof}

Given an event $e\in \Event$, we represent the precondition of an event as $\pre(e)$. The semantics ensures an event will not occur if the precondition is not satisfied. This and \lem{noninter} allows us to sharpen the induction hypothesis further :
    $$ \bigwedge_{i\in \UINS} \bigwedge_{e \in \Event}  (\eec{\mathit{inv}}{c} \wedge \pre(e) \wedge A \Rightarrow \eec{\mathit{inv}}{\Post(\left\{c\right\}, i, e) }).$$


The remainder of this section demonstrates the verification of proposed invariants on three case studies.

 %\rg{Detailed analysis of conditional statements within events?}.

\subsection{Case Study: Lineform}

 We use the executable $\lgname$ semantics to prove \inv{inv:lineform} inductively, as discussed in \refsect{overview}.

We represent the variables in the symbolic post configuration using \emph{primed copies} of the variables in the current configuration. Symbolically executing the effect of the event \evname{TargetUpdate} (for robot $i$) using \K semantics gives us the constraint:

\begin{align*}E := \mathit{M.pos_i}' = M.pos_i &\wedge \mathit{M.tgt_i}' = (x[i-1] + x[i+1])/2 \\ &\wedge x[i]' = \mathit{M.pos}_i\end{align*}.
We omit the details of the $+$ operation, as it is overloaded to extend to vectors.

\asum{lineform-assume} (which is a proof obligation)) in \refsect{overview} is $$A := \mathit{M.pos}_i' \in \mathit{rect}[\mathit{M.pos}_i,\mathit{M.tgt}_i'].$$



For robot $i$, Let the precondition of this event be denoted by $\mathit{Pr}:= \neg (i = \NMAX - 1 \vee i = 0)$.

%The premise of the induction hypothesis is unsatisfiable with the the precondition of this effect for the robots $0$ and $\NMAX-1$, meaning this invariant is vacuously validated for these robots.

The invariant for the current configuration is $$I: \mathit{M.pos}_i \in \mathit{rect}[x_{min}, x_{max}] \wedge x[i] \in \mathit{rect}[x_{min}, x_{max}]$$ and the invariant in the post event configuration is $$I' := \mathit{M.pos}_i' \in \mathit{rect}[x_{min}, x_{max}] \wedge x'[i] \in \mathit{rect}[x_{min}, x_{max}].$$
The overall induction hypothesis then becomes $$ \bigwedge_{i\in \UINS}\mathit{Pr} \wedge E \wedge A \wedge  I \Rightarrow I'.$$
Table \ref{tab:lineform} summarizes the verification of these constraints on systems with different $\NMAX$.

\begin{table}
    \scriptsize
 \centering
   \begin{tabular}{ l|   c c c c  }
 \hline
       (\NMAX) &\tb{dim} & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
   3   & 1 &4.90  &9.09   & \Checkmark  \\
 3   & 2 &4.19  &10.13   & \Checkmark  \\
 4    & 1 &4.79  &12.21  & \Checkmark   \\
4    & 2 &5.28  &12.49  & \Checkmark   \\
 4    & 3 &5.06  &12.77  & \Checkmark   \\
 5   & 1  &4.91  &18.46  & \Checkmark   \\
 5   & 2  &5.60  &18.91  & \Checkmark   \\
5   & 3  &5.42  &20.30  & \Checkmark   \\
10  & 1  &10.92   &32.34   & \Checkmark  \\
10  & 2  &10.96   &32.42   & \Checkmark  \\
10  & 3  &11.34   &33.61   & \Checkmark  \\
 15  & 1 &12.23  & 53.89   &\Checkmark
\end{tabular}
    \caption{ \small Summary of semantics based verification for \LineForm.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for construction of constraints and verification in Z3. Robots moving along a line are represented by \tb{dim} = 1, along a plane by \tb{dim} = 2, and in a 3D space by \tb{dim} = 3.}
            \label{tab:lineform}

\end{table}


We can define a $J$, a weaker invariant which simply constrains the position of each robot, and doesn't constrain the shared $x[i]$, $$J := \mathit{M.pos}_i \in \mathit{rect}[x_{min}, x_{max}] $$ and $J':= \mathit{M.pos}_i' \in \mathit{rect}[x_{min}, x_{max}]$. Table~\ref{tab:lineform1}shows the results we obtained without the proof obligations as assumptions, and this weaker invariant on a system of robots moving in 2D.

\begin{table}
    \scriptsize
 \centering
   \begin{tabular}{ l|   c c c c  }
 \hline
       (\NMAX) &\tb{constraint} & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
   3   & $\Pr \wedge E\wedge I \Rightarrow I'$ &  &  & \emph{Unknown}  \\
 3   & $\Pr \wedge E \wedge J \Rightarrow J'$ &  &   & \emph{Unknown}  \\
 4    & $\Pr\wedge E \wedge I \Rightarrow I' $ &   &  &  \emph{Unknown} \\
4    & $\Pr \wedge E \wedge J\Rightarrow J'$ &  &  & \emph{Unknown}   \\
 4    & $\Pr \wedge E \wedge A \wedge I \Rightarrow I'$ &  &  & \emph{Unknown}   \\
\end{tabular}
    \caption{ \small Verification summary for weaker invariants on \LineForm. The \tb{constraint} column displays the induction hypothesis used in the verification. The verification procedure only tells us that the invariant is not inductive, it doesn't tell us whether the invariant doesn't hold, which is why we don't know whether the system is safe w.r.t the proposed invariant. }
            \label{tab:lineform1}
\end{table}

\newcommand{\Task}{\textsf{Task}\xspace}

\subsubsection{Case Study: \Task}
The problem statement for the \Task application is as follows: Given a set of (possibly heterogeneous) robots, a safety distance $d_s>0$, and a fixed sequence of points (tasks) $\mathit{list} = x_1, x_2, \ldots \in \reals^3$, it is required that: (a) every unvisited $x_i$ in the sequence is {\em visited\/} exactly by one robot; and (b) no two robots ever get closer than $d_s$.

We implemented a fairly straightforward solution shown in \reffig{fig:taskapp}. Robot $i$ looks for an unassigned task $x$ from $\mathit{list}$; if there is a clear path to $x$ then $i$ assigns itself the task $x$. It shares its path with all other robots, and  visits $x$ following the path; once done it repeats the process.  We aim to prove the \emph{safety} of this application with respect to collisions among robots, i.e. \emph{no two robots ever get closer than $d_s$}.

\begin{figure}[t]
    \two{0.4}{0.6}
    {
    \lstinputlisting[language=NumKoord, lastline=20]{code/taskalloc.tex}
    }
    {
    \lstinputlisting[language=NumKoord, firstline=21, firstnumber=21]{code/taskalloc.tex}
    }
    \caption{ $\lgname$ code for robot $i$ for the Distributed Task Allocation}
    \label{fig:taskapp }
\end{figure}


This application has two events \begin{inparaenum} \item {Assign}, in which each robot tries to assign itself to an unassigned task with a clear path  and \item \emph{Complete}, which checks whether an robot has visited its assigned task. \end{inparaenum} The allread variable $\pathvar$ stores either the current path each robot is following to get to a task location, or the current position of a stationary robot. A path here is a list of points that a robot visits in sequence. The \Motion module drives the robot along a path, as directed by the position value set at its actuator port $\mathit{Motion.path}$. The sensor port $\mathit{Motion.planner}$ returns a path to the target of an unassigned task, and a (user-defined) function called $\mathit{pathIsClear}$ is used to determine whether the currently planned path is within $d_s$ distance of any of paths (or positions) in $\pathvar$.

\newcommand{\dist}{\mathit{dist}}
Suppose there is a function $\dist : [Point] \times [Point] \mapsto \mathbb{R}$, where $x$ and $y$ are paths (or positions) of the robots, that returns the minimum distance between $x$ and $y$.
\begin{invariant}
\label{inv:task}
\[\begin{split}
    \forall i,j, \in \UINS, \dist(M.pos_i, M.pos_j) \geq d_s \\ \land \dist(\pathvar[i], \pathvar[j]) \geq d_s
\end{split}
\]
\end{invariant}
\noindent

Computing the $\mathit{pathIsClear}$ function involves two nested loops over the length of each path, then computing the minimum distance between each path segment. Proving invariants over these loops is by itself a difficult (and well studied) problem, so our symbolic execution treats any user-defined functions as uninterpreted functions. We require proof obligations on the output of these functions. For any robot $i$ trying to assign itself to a task, we  assume that $\mathit{pathIsClear}(\mathit{sp}, \mathit{cp} ,i, \mathit{ds})$ returns true only if the shared paths the proposed path $\mathit{cp}$ is always more than $d_s$ distance of any of the shared paths (or positions). \footnote{ The index $i$ in the $\mathit{pathIsClear}$ function indicates that the previously shared path or position of the robot $i$ shouldn't be considered in the computation.}

\begin{proofob}
    \label{pathclear} There is an $\epsilon > 0$:
    $$\forall j \in \UINS, pathIsClear(sp, cp,  i, d_s) \wedge j \neq i \Rightarrow  \dist(sp[j], cp) \geq d_s + \epsilon$$
\end{proofob}


The second proof obligation is that an robot moves closely along its $\mathit{Motion.path}$ actuator whose value is denoted by $\mathit{M.path}$ until it finishes traversing the path. We also denote $\mathit{Motion.reached}$ by $\mathit{M.reached}$.
\begin{proofob}
        \label{stlinemotion}
    $$\mathit{on\_task}_i\wedge \neg \mathit{M.reached}_i \Rightarrow \dist(M.pos_i, sp[i]) \leq \epsilon $$
\end{proofob}

Since we do not want to deal with loop invariants, we verified this protocol for four tasks signified by $\incurly{t_1,t_2,t_3,t_4}$ and we unrolled the for loop iterating through the task list into a sequence of (nested) \emph{if-else} statements. The constraints on the symbolic post event configuration of the \emph{Assign} event for robot $i$ on picking $t_1$ generated by the \K executable semantics as follows: \begin{align*}E_{t_1} &:= \mathit{on\_task}_i' \wedge \mathit{curr\_path}_i' = \mathit{M.planner(t_1.target)} \\ &\wedge \pathvar[i]' = \mathit{curr\_path_i}' \wedge \mathit{M.path}_i' = \pathvar[i]' \\
  &\wedge (\bigwedge_j j\neq i \Rightarrow \pathvar[j]'= \pathvar[j]).
 \end{align*}

Similarly, we get $E_{t_2}$, $E_{t_3}$ and $E_{t_4}$ for the other tasks. For each task, an additional constraint capturing the proof obligation ~\ref{pathclear} on the function $\mathit{PathIsClear}$ is generated as follows:  $A_{t_1} := \forall j \in \UINS, j \neq id, \mathit{dist}(\pathvar[j], \mathit{curr\_path}_i') \geq d_s + \epsilon$ where $\epsilon$ is a positive constant. Similarly we have constraints $A_{t_2}, A_{t_3}$  and $A_{t_4}$ for the other tasks. When none of the tasks is picked, the post event configuration generated is $$ E_{none} :=\neg\mathit{on\_task}_i' \wedge \pathvar[i]' = M.pos_i $$. Since the positions of the robots don't change after the event, \inv{inv:task} for the current configuration for robot $i$ reduces to $$I: \forall j \in \UINS, j \neq i \Rightarrow \mathit{dist}(\pathvar[j], \pathvar[i]) \geq d_s  $$ and the invariant in the post event configuration is $$I' := \forall j \in \UINS, j \neq i \Rightarrow \mathit{dist}(\pathvar[j]', \pathvar[i]') \geq d_s  .$$

The induction hypothesis for event \emph{Assign} then becomes $$ \bigwedge_{i\in \UINS}\mathit{on\_task_i} \wedge \bigvee_{t_j}(E_{t_j} \wedge A_{t_j} \wedge  I) \Rightarrow I'.$$ The induction hypothesis for event \emph{Complete} is generated similarly (omitted here), and the overall induction hypothesis is a conjunction of the two.

Table \ref{tab:task} summarizes the verification of these constraints on systems with different number of robots.
\begin{table}
    \scriptsize
 \centering
   \begin{tabular}{ l|  c c c c  }
 \hline
 \tb{Benchmark}       & $\NMAX$ & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 Task       & 3     &9.90  &10.6   & \Checkmark  \\
 Task       & 4      &9.79  &11.78  & \Checkmark   \\
 Task       & 5      &9.91  &14.92  & \Checkmark   \\
Task        & 10     &12.92   &18.34   & \Checkmark  \\
\end{tabular}
    \caption{ \small Summary of semantics based verification for \Task.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for generation of constraints and verification in Z3 and $\NMAX$ is the number of robots in the system.}
    \label{tab:task}
\end{table}

\subsubsection{Case Study: Mapping}

 The problem requires a set of robots to collaboratively mark the position of static \emph{obstacles} within a given area $D$ quantized by a \emph{grid}, which any robot should avoid while moving in $D$.The key difference between distributed SLAM and this application is that we assume that the robots know their \emph{global coordinates} within the area of deployment. They are only attempting to map the static obstacles within this area. We assume that the only sensors available for sensing obstacles are LIDAR based, and the robots are constrained to move in a 2-D space.

 Our approach requires each robot to construct a \emph{local mapping} of the grid over $D$ using sensors, and update it using information from other robots shared via a \emph{global mapping}. Each mapping essentially maps a set $\qdom \subseteq D \cap \mathbb{Q}^2$ where $\qdom$ is a quantized representation of $D$, to 0 or 1 based on its occupancy.

Suppose there is a \emph{ground truth} function $\world_Q : Q \mapsto \left\{0,1\right\}$ that gives the actual occupancy of obstacles in this quantized arena. That is, $\forall p \in Q$,
\begin{align}
\world_Q(p) =
		\left\{
		\begin{array}{ll}
			1 & \mathit{if}\ p \ \mathit{is \ occupied}\\
			0 & \mathit{otherwise}.
		\end{array}
		\right.
\end{align}

\newcommand{\MotionWithScan}{\emph{MotionWithScan}\xspace}

In $\dmap$, the \MotionWithScan module provides a $\mathit{pscan}$ sensor used to read the LIDAR scan of the actual robot. The other sensors and actuators $\mathit{position,reached,planner,path}$ have the same functionality as that in the \Motion module.

\begin{figure}[t]
    \two{0.4}{0.6}
    {
    \lstinputlisting[language=NumKoord, lastline=20]{code/mapapp.tex}
    }
    {
    \lstinputlisting[language=NumKoord, firstline=21, firstnumber=21]{code/mapapp.tex}
    }
    \caption{ $\lgname$ code for robot $i$ for the Distributed Mapping Application}
    \label{fig:mapapp }
\end{figure}

 The $\lgname$ program corresponding to this solution has three \emph{events}: \emph{NewPoint, LUpdate, GUpdate}. The shared allwrite variable $\gmap$ is used to construct a shared map of obstacles within the domain $D$, and has type $\mathit{GridMap}$, which is a 2-D array representing a grid over $D$. The local variable $\lmap$ represents each robot's \emph{local} knowledge of the domain $D$, and has the same type as $D$. A robot executing the \emph{NewPoint} event, finds an unoccupied point to move to using a user defined function $\mathit{pickFrontierPos}$ and plans a path to it using $\mathit{MotionWithScan.planner}$. It then updates its $\lmap$ from the shared variable $\gmap$. The $\mathit{LUpdate}$ event updates the $\lmap$ with scanned sensor data while the robot is in motion, and the $\mathit{GUpdate}$ event updates the shared $\gmap$ with the updated $\lmap$ information corresponding to the scanned data.


Suppose we have a function $\mathit{snd}: GridMap \mapsto \mathbb{B}$, such that $\mathit{snd}(g)$ returns True if $g$ is consistent with the ground truth function $\world_Q$, and False otherwise. We want to prove that $\gmap$ as well as each robot $i$'s $\lmap_i$ is consistent with the ground truth function:
\begin{invariant}
    \label{inv:mapping}
    $\forall i \in \UINS \mathit{snd(\lmap_i)} \wedge \mathit{snd(\gmap)}$
\end{invariant}

For the \emph{NewPoint} event, the post event configuration for robot $i$ is $E:= \lmap_i' = \gmap \wedge \gmap' = \gmap$.
The induction hypothesis is $I:= \bigwedge_{i\in \UINS} \mathit{snd}(\lmap_i) \wedge \mathit{snd}(\gmap)$, and $I':= \bigwedge_{i\in \UINS} \mathit{snd}(\lmap_i') \wedge \mathit{snd}(\gmap')$ The overall constraint for this event along with its precondition is $$\bigwedge_{i\in \UINS}\neg\mathit{on\_path}\wedge E\wedge I\Rightarrow I'.$$

We also assume that the $\mathit{merge}$ function is such that given two maps satisfying $\mathit{snd}$, it returns a map satisfying $\mathit{snd}$. The specific proof obligation we have then is as follows:
\begin{proofob}
    \label{merge}
    $\forall i \in \UINS, \mathit{snd(\lmap_i)}\wedge \mathit{snd(\gmap)}\Rightarrow \mathit{snd(merge(\gmap,\lmap_i))}$,
\end{proofob}

For the event \emph{GUpdate}, we get the post event configuration for robot $i$ as $G:= \lmap_i' = \lmap_i \wedge \gmap' = \mathit{merge}(\gmap,\lmap_i)$. The proof obligation ~\ref{merge} is stated as \begin{align*}M:= \bigwedge_{i\in \UINS}, &\mathit{snd(\lmap_i)}\wedge \mathit{snd(\gmap)}\\ &\Rightarrow \mathit{snd(merge(\gmap,\lmap_i)).}\end{align*} The overall constraint for this event along with its precondition is therefore : $$\bigwedge_{i\in \UINS} \mathit{MWS}.reached \wedge G \wedge M \wedge I \Rightarrow I'$$. We omit the discussion for \emph{LUpdate} in the interest of space, as it follows along the lines of the previous constraints. It requires an additional proof obligation on the $\mathit{scanToMap}$ function and the consistency of the sensor data $\mathit{MotionWithScan.pscan}$ with the ground truth, along with unrolling the \emph{for-loop} to the number of sensor observations. The overall induction hypothesis is a conjunction of the three.

Table \ref{tab:map} summarizes the verification of these constraints on systems of different $\NMAX$ .
\begin{table}
    \label{tab:map}
    \scriptsize
 \centering
   \begin{tabular}{ l|  c c c c  }
 \hline
 \tb{Benchmark}       & \tb{robots}(N) & $T_K$ (s) & $T_V$ (s)   & \qquad\tb{Safe\ \ \ \ } \\ \hline
 \dmap       & 3     &  &   & \Checkmark  \\
 \dmap      & 4      &  &  & \Checkmark   \\
 \dmap       & 5      &  &  & \Checkmark   \\
\dmap        & 10     &   &   & \Checkmark  \\
\end{tabular}
    \caption{ \small Summary of semantics based verification for \dmap.  $T_K$ is the symbolic post computation time in \K, $T_V$ is the time taken for generation of constraints and verification in Z3 and \emph{robots}(N) is the number of robots in the system.}
\end{table}

